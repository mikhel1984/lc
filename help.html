<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Sonata LC Help</title>
</head><body>
<a name="Top"></a>
<h3 align="center"># Modules #</h3>
<ul>
<li><a href="#Arr">array</a></li>
<li><a href="#Big">bigint</a></li>
<li><a href="#Comp">complex</a></li>
<li><a href="#_C">const</a></li>
<li><a href="#File">files</a></li>
<li><a href="#Gnu">gnuplot</a></li>
<li><a href="#Graph">graph</a></li>
<li><a href="#Mat">matrix</a></li>
<li><a href="#Num">numeric</a></li>
<li><a href="#Poly">polynom</a></li>
<li><a href="#Rat">rational</a></li>
<li><a href="#Spec">special</a></li>
<li><a href="#Stat">stat</a></li>
<li><a href="#DS">struct</a></li>
<li><a href="#Unit">units</a></li>
</ul>
<h3 align="center"># About #</h3>
<p><br>
'Sonata LC' is a Lua based program for mathematical calculations.<br>
<br>
<b>USAGE</b>:<br>
	lua -i sonata.lua [flag [arg1 arg2 ...]]<br>
(option '-i' could be omitted when the program is in non-interractive mode)<br>
<br>
<b>FLAGS</b>:<br>
	-h, --help - Get this help message.<br>
	-n, --new - Generate template for a new module.<br>
	-d, --doc - Create/update documentation file.<br>
	-t, --test - Apply unit tests to desired module, or all modules if the name is not defined.<br>
	-e, --eval - Evaluate command line expression(s).<br>
	-l, --lng - Create/update file for localisation.<br>
<br>
<b>VERSION</b>: 0.9.3<br>
<br>
<b>MODULES</b>: stat, matrix, numeric, complex, units, struct, const, array, rational, special, gnuplot, bigint, files, polynom, graph.<br>
<br>
<b>BUGS</b>: mail to 'sonatalc@yandex.ru'<br>
</p>
<p><a href="https://github.com/mikhel1984/lc/wiki">WIKI</a></p>
<a name="Main"></a>
<h3 align="center"># Main (main) #</h3>
<p align="center">Lua как расширяемый калькулятор</p>
<p><b>_e</b> - Число Эйлера.<br>
<b>_pi</b> - Число пи.<br>
<b>abs(x)</b> - Абсолютная величина.<br>
<b>ach(x)</b> - Гиперболический арккосинус x.<br>
<b>acos(x)</b> - Арккосинус числа x.<br>
<b>ash(x)</b> - Гиперболический арксинус x.<br>
<b>asin(x)</b> - Арксинус числа x.<br>
<b>atan(y[,x])</b> - Арктангенс числа y. Если заданы 2 аргумента, тангенс определяется как y/x с учётом знаков.<br>
<b>ath(x)</b> - Гиперболический арктангенс x.<br>
<b>ceil(x)</b> - Возвращает наименьшее целое, большее или равное x.<br>
<b>ch(x)</b> - Гиперболический косинус x.<br>
<b>cos(x)</b> - Косинус числа x.<br>
<b>deg(x)</b> - Преобразование радиан в градусы.<br>
<b>deserialize(obj_str)</b> - Преобразует строку сериализации в объект Sonata LC.<br>
<b>example(name)</b> - Печатает примеры для данного модуля. В качестве примеров используются тестовые выражения.<br>
<b>exp(x)</b> - Экспоненциальная зависимость.<br>
<b>fact(n)</b> - Evaluate factorial.<br>
<b>flip(t[,N])</b> - Отображает содержимое таблицы Lua в удобном для пользователя виде. Спрашивает о продолжении после каждых N элементов (по умолчанию 10).<br>
<b>floor(x)</b> - Возвращает наибольшее целое, меньшее или равное x.<br>
<b>import</b> - <br>
<b>lc.append(tbl,val)</b> - Append value or table to the given table.<br>
<b>lc.pause([str])</b> - Wait for button press, print text if need.<br>
<b>lc.range([from,]to[,step])</b> - Generate table with sequence of numbers.<br>
<b>lg(x)</b> - Десятичный логарифм.<br>
<b>ln(x)</b> - Натуральный логарифм.<br>
<b>max(...)</b> - Находит максимальное из чисел.<br>
<b>min(...)</b> - Находит минимальное из чисел.<br>
<b>rad(x)</b> - Преобразование градусов в радианы.<br>
<b>rand()</b> - Случайное число между 0 и 1.<br>
<b>round(x[,n])</b> - Round value, define number of decimal digits.<br>
<b>sci(x)</b> - 'Scintific' representation of the number.<br>
<b>sh(x)</b> - Гиперболический синус x.<br>
<b>sin(x)</b> - Синус числа x.<br>
<b>sqrt(a)</b> - Квадратный корень числа.<br>
<b>tan(x)</b> - Тангенс числа x.<br>
<b>th(x)</b> - Гиперболический тангенс x.<br>
<b>type(t)</b> - Show type of the object.<br></p>
<pre style="background-color: silver; width: 700px;">
lc = require 'liblc.main'

-- constants starts from _
ans = _pi                        --> math.pi

-- round number
ans = round(0.9)                 --> 1.0

-- save 2 digits
ans = round(math.pi, 2)          --> 3.14

-- 'small' factorial - int
ans = fact(12)                   --> 479001600

-- 'big' factorial - float
ans = fact(50)                   --~ 3.0414E+64

-- get object type
ans = lc.type(25)                --> 'integer'

-- show table components
a = {a=1,b=2;3,4,5}
lc.flip(a)

-- generate 'vector'
b = lc.range(3)
ans = b[3]                      --> 3

-- full form
b = lc.range(2,10,2)
ans = b[2]                      --> 4

-- append a to b
lc.append(b,a)
ans = b.b                       --> 2
</pre>
<a href="#Top">Top</a>
<a name="Arr"></a>
<h3 align="center"># Arr (array) #</h3>
<p align="center">Манипуляции с массивами элементов. По-умолчанию, массив разряженный.</p>
<p><b>#arr</b> - Return maximum number of elements.<br>
<b>Arr(size)</b> - Формирует пустой массив заданной размерности.<br>
<b>apply(a1,a2,fn)</b> - Применить к массивам функцию двух переменных. Возвращает новый массив.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, -a, a^b<br>
<b>comparison</b> - a == b, a ~= b<br>
<b>concat(a1,a2,axe)</b> - Объединение двух массивов вдоль заданной оси.<br>
<b>copy(arr)</b> - Создание копии массива.<br>
<b>dim(arr)</b> - Возвращает список размеров массива.<br>
<b>fullString(arr,r,c)</b> - Represent array as sequence of matrices, where r and c are numbers of axes.<br>
<b>get(arr,ind)</b> - Извлечь значение элемента. Индекс представлен в виде таблицы.<br>
<b>isEqual(a1,a2)</b> - Check size equality.<br>
<b>map(a,fn)</b> - Применить к массиву функцию одного переменного. Возвращает новый массив.<br>
<b>next(arr)</b> - Возвращает итератор по всем индексам значениям массива.<br>
<b>rand(size)</b> - Возвращает массив случайных чисел заданной размерности.<br>
<b>serialize(obj)</b> - Строковое представление массива с учётом внутренней структуры.<br>
<b>set(arr,ind,val)</b> - Установить значение элемента. Индекс в виде таблицы.<br>
<b>sub(arr,ind1,ind2)</b> - Выделение части массива, ограниченной двумя индексами.<br></p>
<pre style="background-color: silver; width: 700px;">
Arr = require 'liblc.array'

-- empty array
a = Arr {2,3,4}                       
ans = a:get{1,2,1}                     --> nil

-- set values
a:set({1,2,1},4)
ans = a:get{1,2,1}                     --> 4

-- random array
b = Arr.rand {5,2,1}
-- number of elements
ans = #b                               --> 10

ans = b:copy()                         --> b

-- compare sizes
ans = b:isEqual(Arr.rand{5,2,1})       --> true

-- arithmetical operations
c = b + b
ans = c:get{1,1,1}                     --> 2*b:get{1,1,1}

-- get sub array
g = a:sub({1,1,1},{-1,-1,2})         
ans = g:isEqual(Arr{2,3,2})            --> true

-- concatenate along the 3-rd axes
d = Arr.concat(b,b,3)
ans = d:dim()[3]                       --> 2

-- apply functions of 2 arguments
-- to get new array
e = Arr.apply(b,b, function (x,y) return x*y end)
ans = e:get{1,1,1}                     --> (b:get{1,1,1})^2

-- apply function of 1 argument
-- to get new array
f = b:map(function (x) return 10*x end)
ans = f:get{1,1,1}                     --> b:get{1,1,1}*10

-- simple print
print(a)

-- print slices for axis 2 and 3
print(d:fullString(2,3))
</pre>
<a href="#Top">Top</a>
<a name="Big"></a>
<h3 align="center"># Big (bigint) #</h3>
<p align="center">Операции с целыми числами произвольной точности.</p>
<p><b>BASE</b> - Основание системы счисления.<br>
<b>Big(v)</b> - Создаёт целое число произвольной точности из обычного числа или строки.<br>
<b>abs(v)</b> - Абсолютное значение целого числа.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a%b, a^b, -a, #a<br>
<b>comparison</b> - a<b, a<=b, a>b, a>=b, a==b, a~=b<br>
<b>copy(v)</b> - Создаёт копию числа.<br>
<b>digits(v)</b> - Number of digits, the same as #v.<br>
<b>eq(a,b)</b> - Проверяет равенство двух чисел.<br>
<b>fact(n)</b> - Факториал неотрицательного целого числа.<br>
<b>serialize(obj)</b> - Строковое представление числа произвольной точности с учётом внутренней структуры.<br>
<b>str(v)</b> - Более удобное отображение длинного числа.<br>
<b>tonumber(v)</b> - Преобразует число к целому либо с плавающей точкой.<br></p>
<pre style="background-color: silver; width: 700px;">
Big = require 'liblc.bigint'

-- from integer
a = Big(123)         
ans = a:tonumber()           --> 123

-- from string
b = Big('456')        
ans = b:tonumber()           --> 456

-- arithmetical operations
ans = Big.tonumber(a+b)      --> 579

ans = Big.tonumber(a-b)      --> -333

ans = Big.tonumber(a*Big(2)) --> 246

ans = Big.tonumber(b/2)      --> 228

ans = Big.tonumber(b%a)      --> 87

ans = Big.tonumber(a^3)      --> 1860867

-- absolute value
ans = Big.tonumber(Big.abs('-25')) --> 25

-- factorial
c = Big(10):fact()
ans = Big.tonumber(c)  --> 3628800

-- make copy, comparision
d = a:copy()
ans = (a == d)               --> true

ans = (a > b)                --> false

ans = (a == b)               --> false

-- compare with number
ans = a:eq(123)              --> true

-- number of digits
-- in Lua5.1 use 'digits' method
ans = #a                     --> 3

-- simple print
print(a)

-- more friendly representation
print(c:str())
</pre>
<a href="#Top">Top</a>
<a name="Comp"></a>
<h3 align="center"># Comp (complex) #</h3>
<p align="center">Комплексные числа и манипуляции с ними.</p>
<p><b>Comp(a[,b])</b> - Новое комплексное число.<br>
<b>Im(v)</b> - Мнимая часть числа.<br>
<b>Re(v)</b> - Действительная часть числа.<br>
<b>_i</b> - Комплексная единица.<br>
<b>abs(v)</b> - Возвращает модуль комплексного числа.<br>
<b>arg(v)</b> - Вычисляет аргумент (угол) комплексного числа.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^b, -a<br>
<b>comparison</b> - a==b, a~=b<br>
<b>conj(v)</b> - Возвращает комплексно сопряжённое число.<br>
<b>copy(c)</b> - Возвращает копию комплексного числа.<br>
<b>serialize(obj)</b> - Строковое представление комплексного числа с учётом внутренней структуры.<br>
<b>sqrt(v)</b> - Квадратный корень положительного или отрицательного числа.<br>
<b>trig(module,angle)</b> - Создаёт комплексное число на основе тригонометрического представления.<br></p>
<pre style="background-color: silver; width: 700px;">
Comp = require 'liblc.complex'

-- real and imag pars
a = Comp(1,2)
-- or just real                  
b = Comp(3)
ans = b                        --> Comp(3,0)

-- imaginary unit
j = Comp._i
ans = 3+4*j                    --> Comp(3,4)

-- use trigonometrical form
ans = Comp.trig(2,0)           --> Comp(2,0)

-- arithmetic
ans = a + b                    --> Comp(4,2)

ans = Comp(3) - b              --> Comp(0)

ans = a * b                    --> Comp(3,6)

ans = a / Comp._i              --> Comp(2,-1)

-- power could be complex
c = Comp(1,1)^Comp(2,-2)
-- real part
ans = c:Re()                   --~ 6.147

-- imaginary part
ans = c:Im()                   --~ 7.4

-- comparison
ans = (a == b)                 --> false

ans = (a ~= b)                 --> true

-- absolute value
ans = a:abs()                  --~ 2.236

-- argument (angle)
ans = a:arg()                  --~ 1.107

-- conjugated number
ans = a:conj()                 --> Comp(1,-2)

-- complex square root
-- after import becomes default
d = Comp.sqrt(-2)
ans = d:Im()                   --~ 1.414

-- make copy
ans = a:copy()                 --> a

-- show
print(a)
</pre>
<a href="#Top">Top</a>
<a name="_C"></a>
<h3 align="center"># _C (const) #</h3>
<p align="center">Набор констант.</p>
<p><b>Adams</b> - Ответ на главный вопрос о жизни, вселенной и всего такого.<br>
<b>EuMa</b> - Difference between harmonic series and the natural logarithm.<br>
<b>G</b> - Гравитационная постоянная.<br>
<b>NA</b> - Число Авогадро.<br>
<b>R</b> - Универсальная газовая постоянная.<br>
<b>Rinf</b> - Rydberg constant<br>
<b>Vm</b> - Объём моля идеального газа.<br>
<b>c</b> - Скорость света в вакууме.<br>
<b>e</b> - Заряд электрона.<br>
<b>eps0</b> - Электрическая постоянная.<br>
<b>g</b> - Ускорение свободного падения.<br>
<b>h</b> - Постоянная Планка.<br>
<b>k</b> - Постоянная Больцмана.<br>
<b>ly</b> - One light year.<br>
<b>mu0</b> - Магнитная постоянная.<br>
<b>pc</b> - One parsec.<br>
<b>phi</b> - Золотое сечение.<br>
<b>sigma</b> - Stefan-Boltzmann constant.<br></p>
<pre style="background-color: silver; width: 700px;">
_C = require 'liblc.const'

-- charge of electron
ans = _C.e                  --~ 1.602e-19

-- units has postfix _u
ans = _C.e_u                --> 'C'
</pre>
<a href="#Top">Top</a>
<a name="File"></a>
<h3 align="center"># File (files) #</h3>
<p align="center">Вспомогательные функции для работы с файлами.</p>
<p><b>dsvRead(fname,del)</b> - Read delimiter separated data as Lua table.<br>
<b>dsvWrite(fname,tbl,del)</b> - Save Lua table as delimiter separated data into file.<br>
<b>split(str,delim)</b> - Генерирует итератор, который возвращает части строки с учётом разделителя.<br>
<b>tblExport(fname,tbl)</b> - Save Lua table into file.<br>
<b>tblImport(fname)</b> - Import Lua table, written into file.<br></p>
<pre style="background-color: silver; width: 700px;">
File = require 'liblc.files'
nm = os.tmpname()

-- save table 
-- separate elements with ';'
t = {{1,2,3},{4,5,6}}
File.dsvWrite(nm, t, ';')

-- read table from file
-- with separator ';'
tt = File.dsvRead(nm, ';')
ans = tt[2][2]                       --> 5

-- get file text as string
s = File.read(nm)
ans = string.sub(s,1,5)              --> '1;2;3'

-- serialize table to file
a = {1, 2.0, a = 'pqr', b = {3,4,c='abc'}}
File.tblExport(nm, a)

-- deserialize table from file
aa = File.tblImport(nm)
ans = aa.b.c                         --> 'abc'

-- string split
str = 'abc//defg//hijkl//mnop'
ans = 0
for s in File.split(str, '//') do ans = ans+1 end  --> 4

</pre>
<a href="#Top">Top</a>
<a name="Gnu"></a>
<h3 align="center"># Gnu (gnuplot) #</h3>
<p align="center">Интерфейс для работы с Gnuplot из Lua.</p>
<p><b>Gnu([g])</b> - Делает таблицу Gnuplot-совместимым объектом программы.<br>
<b>N</b> - Если шаг не указан, интервал делится на данное количество отрезков.<br>
<b>copy(g)</b> - Создаёт копию объекта с параметрами построения графика.<br>
<b>isAvailable(g)</b> - Check if all options in table are predefined in program.<br>
<b>keys</b> -   Описание параметров:<br>
{'sin(x)'}                                   -- функция задана в текстовом виде<br>
{math.sin, title='sinus'}                    -- строит график для Lua функции, добавляет текст в легенду<br>
{file='sin.dat', ln=1, lw=2}                 -- строит график для файла с учётом цвета и толщины маркеров<br>
{tbl, with='lines'}                          -- строит график для Lua таблицы с помощью линий<br>
title='Graph name'                           -- имя графика в целом<br>
xrange={0,10}                                -- диапазон x от 0 до 10<br>
yrange={-2,2}                                -- диапазон y<br>
zrange={0,5}                                 -- диапазон z<br>
trange={1,2}                                 -- изменение параметра в случае параметрической функции<br>
xtitle='A', ytitle='B'                       -- имена осей<br>
terminal='jpeg'                              -- сохранение результата в файл<br>
output='my_plot.jpg'                         -- имя файла для вывода результата<br>
parametric=true                              -- параметрическое представление функции<br>
size='square'                                -- установить квадратный размер изображения<br>
polar=true                                   -- график в полярных координатах<br>
grid='polar'                                 -- изменить тип сетки на полярный<br>
legend=false                                 -- отключить легенду<br>
surface=true                                 -- построение трёхмерного графика<br>
samples=200                                  -- задать число точек на графике<br>
permanent=true                               -- сохранить окно графика при завершении программы (по-умолчанию)<br>
raw='set pm3d'                               -- позволяет написать команды Gnuplot в явном виде<br>
<br>
<b>plot(g)</b> - Строит график функций, представленных в виде таблицы Lua.<br></p>
<a href="#Top">Top</a>
<a name="Graph"></a>
<h3 align="center"># Graph (graph) #</h3>
<p align="center">Operations with graphs.</p>
<p><b>BellmanFord(start[,goal]</b> - Shortest path search using Bellman-Ford algorithm.<br>
<b>Dijkstra(g,start[,goal]</b> - Find shortest path using Dijkstra's algorithm. Return table of distances and predecessors. If goal is defined, return path and its length.<br>
<b>Graph(t)</b> - Create new graph.<br>
<b>add(e)</b> - Add new node or edge. Node denoted as a single name, edge is a table of names (and weights if need).<br>
<b>bfs(g,start,goal)</b> - Bredth first search. Return result and found path.<br>
<b>copy()</b> - Get copy of the graph.<br>
<b>dfs(start,goal)</b> - Depth first search. Return result and found path.<br>
<b>edges()</b> - List of graph edges.<br>
<b>isComplete(g)</b> - Check completeness of the graph.<br>
<b>nodes()</b> - List of graph nodes.<br>
<b>remove(e)</b> - Remove node or edge. Node is a single name, edge - talbe of names.<br>
<b>spath(start[,goal])</b> - Find shortest path using algorithm of Dijkstra of Bellman-Ford.<br></p>
<pre style="background-color: silver; width: 700px;">
Graph = require 'liblc.graph'

-- build graph
-- single names - nodes, names in brackets - edges 
-- letter w denotes weight of non directed edge
-- numbers are weigths of directed edges
a = Graph {'a','b',{'a','c'},{'d','e',w=2},{'d','b',4,3}}

-- list of nodes
nd = a:nodes()
ans = #nd                      --> 5

-- list of edges
ed = a:edges()
ans = #ed                      --> 3

-- add node
a:add('h') 
-- add edge
a:add {'a','d'}
-- check size
ans = #a                       --> 6

-- remove edge
a:remove {'a','d'}
-- remove node
a:remove('a')
-- new edge number
ed = a:edges()
ans = #ed                      --> 2

-- make copy
b = a:copy()

-- show
print(b)

</pre>
<a href="#Top">Top</a>
<a name="Mat"></a>
<h3 align="center"># Mat (matrix) #</h3>
<p align="center">Операции с матрицами. Индексация начинается с 1. По-умолчанию, матрицы разряжённые.</p>
<p><b>Cholesky(m)</b> - Cholesky decomposition of positive definite symmetric matrix.<br>
<b>Mat(...)</b> - Формирование матрицы. Аргументы являются списком строк, каждая из которых - таблица чисел.<br>
<b>apply(m1,m2,fn)</b> - Применяет fn(v1,v2) к каждой паре элементов матриц m1 и m2.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^b, -a<br>
<b>comparison</b> - a==b, a~=b<br>
<b>concat(m1,m2,dir)</b> - Объединяет 2 матрицы по горизонтали (dir='h') или вертикали (dir='v').<br>
Для горизонтальной конкатенации можно использовать запись m1..m2, для вертикальной - m1//m2.<br>
<b>copy(m)</b> - Возвращает копию матрицы.<br>
<b>cross(a,b)</b> - Векторное произведение 3-элементных векторов.<br>
<b>dense(m)</b> - Возвращает плотную матрицу.<br>
<b>det(m)</b> - Определитель матрицы.<br>
<b>diag(M[,n])</b> - Возвращает диагональные элементы либо создаёт матрицу, используя заданный вектор в качестве диагонали со смещением n.<br>
<b>dot(a,b)</b> - Скалярное произведение двух 3-элементных векторов.<br>
<b>eye(rows[,cols[,init]])</b> - Create identity matrix. Diagonal value (init) can be nonzero.<br>
<b>fill(rows,cols,fn)</b> - Формирует матрицу, элементы которой определяются функцией fn(r,c).<br>
<b>inv(m)</b> - Вычисляет обратную матрицу.<br>
<b>lu(m)</b> - LU разложение матрицы. Возвращает L,U и P элементы.<br>
<b>map(m,fn)</b> - Применяет указанную функцию fn(x) ко всем элементам матрицы, возвращает новую матрицу.<br>
<b>mapEx(m,fn)</b> - Apply function fn(row,col,val) to all elements, return new matrix.<br>
<b>ones(rows[,cols[,val]])</b> - Формирует матрицу, все элементы которой равны заданному числу (по-умолчанию 1).<br>
<b>pinv(M)</b> - Вычисление псевдоинверсной матрицы через SVD разложение.<br>
<b>rand(rows[,cols])</b> - Матрица случайных чисел от 0 до 1.<br>
<b>rank(m)</b> - Находит ранг матрицы.<br>
<b>reduce(m,fn,dir,init)</b> - Вычисляет функцию s=fn(s,x) вдоль строк (dir='r') или столбцов (dir='c'), s0=init - начальное значение.<br>
<b>rref(A,b)</b> - Применяет метод Гаусса для решения системы линейных уравнений. Возвращает полученную матрицу и детерминант.<br>
<b>serialize(obj)</b> - Строковое представление матрицы с учётом внутренней структуры.<br>
<b>set(m,row,col)(val)</b> - Установить значение элемента матрицы.<br>
<b>size(m)</b> - Возвращает число строк и столбцов матрицы.<br>
<b>sparse(m)</b> - Возвращает разряжённую матрицу.<br>
<b>sqNorm(m,dir)</b> - Calculate square norm along given direction.<br>
<b>sum(m,dir)</b> - Вычисление суммы элементов вдоль заданного направления ('r' или 'c').<br>
<b>tr(m)</b> - След матрицы.<br>
<b>transpose(m)</b> - Возвращает транспонированную матрицу. Сокращённая форма - T().<br>
<b>triang(m)</b> - Приведение к треугольному виду методом Гаусса.<br>
<b>zeros(rows[,cols])</b> - Матрица нулей с заданными размерами.<br></p>
<pre style="background-color: silver; width: 700px;">
Mat = require 'liblc.matrix'

-- define matrix objects
a = Mat {{1,2},{3,4}}             
b = Mat {{5,6},{7,8}}  
-- call in typical way           
ans = a[2][2]                    --> 4 

-- use index checking
b:set(1,1)(9)
ans = b:get(1,1)                 --> 9

b[1][1] = 5
-- transpose
c = a:T()
-- use () as alias for get()
ans = c(1,-1)                    --> 3

-- matrix rows and columns
_, ans = a:size()                --> 2

-- arithmetical operations
ans = a + b                      --> Mat {{6,8},{10,12}}

ans = b - a                      --> Mat {{4,4},{4,4}}

ans = a * b                      --> Mat {{19,22},{43,50}}

ans = a / b 
-- determinant
ans = ans:det()                  --~ 1

-- multiply to scalar
ans = 2 * a                      --> Mat {{2,4},{6,8}}

-- add scalar (to all elements)
ans = a - 1                      --> Mat {{0,1},{2,3}}

ans = a ^ 2                      --> Mat {{7,10},{15,22}} 

-- determinant
ans = a:det()                    --> -2

-- inverse matrix
e = a:inv()
ans = e(2,1)                     --> 1.5

-- another call of inversion
e = a^-1
ans = e(2,1)                     --> 1.5

-- object copy
f = a:copy()
ans = (f == a)                   --> true

-- element-wise comparison
ans = (a == b)                   --> false

-- identity matrix
ans = Mat.eye(2)                 --> Mat {{1,0},{0,1}}

-- matrix of zeros
ans = Mat.zeros(2,1)             --> Mat {{0},{0}}

-- matrix of constants = 4
ans = Mat.ones(2,3,4)            --> Mat {{4,4,4},{4,4,4}}

-- matrix of constants = 1
ans = Mat.ones(a,3)              --> Mat {{3,3},{3,3}}

-- horizontal concatenation
ans = a .. b                     --> Mat {{1,2,5,6},{3,4,7,8}}

-- vertical concatenation
ans = a // b                     --> Mat {{1,2},{3,4},{5,6},{7,8}}

-- apply function of 1 argument
ans = a:map(function (x) return x^2 end)          --> Mat {{1,4},{9,16}}

-- apply function which depends on index too
ans = a:mapEx(function (x,r,c) return x-r-c end) --> Mat {{-1,-3},{-2,-4}}

-- use Gauss transform to solve equation
ans = Mat.rref(a, Mat {{5},{11}}) --> Mat {{1,0,1},{0,1,2}}

-- create vector
ans = Mat.V {1,2,3}              --> Mat {{1},{2},{3}}

-- get submatrix
g = Mat {{1,2,3},{4,5,6},{7,8,9}}
ans = g({2,-1},{2,3})           --> Mat {{5,6},{8,9}}

-- random matrix
h = Mat.rand(3,2)
print(h)

-- pseudoinverse matrix
m = Mat {{1,2},{3,4},{5,6}}
n = m:pinv()
ans = n(2,2)                    --~ 0.333

-- get dense copy of the matrix
k = Mat.eye(3)
k = k:dense()
ans = k[2][1]                   --> 0

k = k:sparse()
ans = rawget(k[2],1)             --> nil

-- make diagonal matrix
ans = Mat.diag({1,2,3})         --> Mat {{1,0,0},{0,2,0},{0,0,3}}

-- shifted diagonal
ans = g:diag(1)                 --> Mat {{2},{6}}

-- cross-product of 2 vectors
x1 = Mat {{1,2,3}}
x2 = Mat {{4,5,6}}
ans = Mat.cross(x1,x2)          --> Mat {{-3},{6},{-3}}

-- dot product of 2 vectors
ans = Mat.dot(x1,x2)            --> 32

-- LU transform
l,u,p = b:lu()
ans = l[2][1]                   --~ 0.714

-- Cholesky decomposition
m = Mat {{3,1},{1,3}}
m = m:Cholesky()
ans = m[2][2]                   --~ 1.633

-- matrix trace
ans = a:tr()                    --> 5

-- extract first row
m = a({},1)
-- vector doesn't need in 2 indices
ans = m(1)                      --> 1

-- extract last column
-- index can be negative 
m = a(-1,{})
ans = m:get(2)                  --> 4

-- apply summation to each row
ans = a:sum()                   --> Mat {{3},{7}}

-- apply product to each column
-- initial value is 1
ans = a:reduce(function (x,y) return x*y end, 'c', 1) --> Mat {{3,8}}

-- get rank
ans = Mat.ones(2,3):rank()      --> 1
</pre>
<a href="#Top">Top</a>
<a name="Num"></a>
<h3 align="center"># Num (numeric) #</h3>
<p align="center">Применение численных методов для решения ряда задач.</p>
<p><b>Newton(fn,x0)</b> - Find root of equation using Newton's rule, use only one initial condition.<br>
<b>TOL</b> - Точность вычислений (0.001 по умолчанию).<br>
<b>diff(fn,x)</b> - Численное дифференцирование в заданной точке.<br>
<b>ode(fn,init,break[,dx])</b> - Numerical approximation of the ODE solution.<br>
If step dx is not defined it is calculated automatically according the given tolerance.<br>
Return table of intermediate points and result yn.<br>
<b>solve(fn,a,b)</b> - Поиск решения уравнения на заданном интервале.<br>
<b>trapez(fn,a,b)</b> - Численное интегрирование на указанном интервале.<br></p>
<pre style="background-color: silver; width: 700px;">
Num = require 'liblc.numeric'

-- define tolerance
Num.TOL = 1e-4
-- solve 'sin(x) = 0' for x in (pi/2...3*pi/2)
a = Num.solve(math.sin, math.pi*0.5, math.pi*1.5)
ans = a                                   --~ math.pi

-- Newton method
-- only one initial value
d = Num.Newton(math.sin, math.pi*0.7)
ans = d                                   --~ math.pi

-- numeric derivative
b = Num.diff(math.sin, 0)
ans = b                                   --~ 1

-- numeric integral
c = Num.trapez(math.sin, 0, math.pi)      
ans = c                                   --~ 2

-- solve ODE x*y = x'
-- for x = 0..3, y(0) = 1
-- return table of solutions and y(3)
tbl, yn = Num.ode(function (x,y) return x*y end, {0,1}, 3)
ans = yn                                  --~ 90.011

-- use matrices for high order equations
Mat = require 'liblc.matrix'

-- y''-2*y'+2*y = 1
-- represent as: x1 = y, x2 = y'
-- so: x1' = x2, x2' = 1+2*x2-2*x1
myfun = function (t,x) return Mat.V {x(2), 1+2*x(2)-2*x(1)} end
_, xn = Num.ode(myfun, {0, Mat.V{3,2} }, 2, 0.2) 
ans = xn(1)                               --~  -10.54

-- define exit condition
-- from time, current and previous results
exit = function (t,c,p) return c < 0.1 end
myfun = function (t,x) return -x end
_, yn = Num.ode(myfun, {0,1}, exit)
ans = yn                                  --~ 0.0856
</pre>
<a href="#Top">Top</a>
<a name="Poly"></a>
<h3 align="center"># Poly (polynom) #</h3>
<p align="center">Операции с полиномами.</p>
<p><b>Poly(...)</b> - Формирует полином из списка коэффициентов.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^n, -a<br>
<b>coef(...)</b> - Вычисляет полином через список его корней.<br>
<b>comparison</b> - a<b, a<=b, a>b, a>=b, a==b, a~=b<br>
<b>copy(p)</b> - Создание копии полинома.<br>
<b>der(p[,x])</b> - Вычисление производной полинома. Возвращает значение в точке, если она задана.<br>
<b>fit(X,Y,ord)</b> - Аппроксимация данных полиномом заданной степени.<br>
<b>int(p[,x0])</b> - Вычисляет первообразную интеграла, x0 - свободный коэффициент<br>
<b>real(p)</b> - Возвращает список действительных корней полинома.<br>
<b>serialize(obj)</b> - Строковое представление полинома с учётом внутренней структуры.<br>
<b>val(p,x)</b> - Вычисляет значение полинома в заданной точке.<br></p>
<pre style="background-color: silver; width: 700px;">
Poly = require 'liblc.polynom'

-- coefficients in ascendant order
a = Poly {1,2,4,3}           
b = Poly {1,1}   
-- polynomial value for x=0             
ans = a:val(0)                --> 3

-- simplified call
ans = a(0)                    --> 3

-- arithmetic
ans = a + b                   --> Poly {1,2,5,4}

ans = a - b                   --> Poly {1,2,3,2}

ans = b * b                   --> Poly {1,2,1}

ans = a / b                   --> Poly {1,1,3}

ans = a % b                   --> Poly {0}

ans = b ^ 3                   --> Poly {1,3,3,1}

-- integration
-- free coefficient is 0
ans = b:int()                 --> Poly {0.5,1,0}

-- derivative
-- and its value for x=1
_,ans = a:der(1)              --> 11

-- build polynomial using roots
ans = Poly.coef(1,-1)         --> Poly {1,0,-1}

-- make copy and compare
c = a:copy()
ans = (a == c)                --> true

ans = (b == c)                --> false

-- find real roots
e = a:real()
ans = e[1]                    --~ -1.00

-- fit curve with polynomial
-- of 2 order
A={0,1,2,3}
B={-3,2,11,24}
p = Poly.fit(A,B,2)
ans = p(10)                   --~ 227.0

-- simple print
print(a)

-- human-friendly print
-- with varialbe 's'
d = Poly {2,-2,1}
ans = d:str('s')              --> '2*s^2-2*s+1'
</pre>
<a href="#Top">Top</a>
<a name="Rat"></a>
<h3 align="center"># Rat (rational) #</h3>
<p align="center">Операции с целыми числами произвольной длины.</p>
<p><b>De(v)</b> - Знаменатель рационального числа.<br>
<b>Nu(v)</b> - Числитель рационального числа.<br>
<b>Rat(m[,n])</b> - Возвращает рациональное число с указанными числителем и знаменателем (если задан).<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, -a, a^b} <br>
<b>comparison</b> - a<b, a<=b, a>b, a>=b, a==b, a~=b <br>
<b>copy(v)</b> - Возвращает копию рационального числа.<br>
<b>decimal(v)</b> - Возвращает десятичное представление дроби.<br>
<b>gcd(a,b)</b> - Наименьшее общее кратное двух чисел.<br>
<b>serialize(obj)</b> - Строковое представление рационального числа с учётом внутренней структуры.<br></p>
<pre style="background-color: silver; width: 700px;">
Rat = require 'liblc.rational'

-- numerator, denominator
a = Rat(1,2)
-- only numerator
b = Rat(2)
ans = b                 --> Rat(2,1)

-- simplification
k = 234781
ans = Rat(2*k,3*k)      --> Rat(2,3)

-- arithmetic
ans = a + b             --> Rat(5,2)

ans = 2 * a             --> Rat(1)

ans = Rat(2,3)*Rat(3,2) --> Rat(1)

ans = a / Rat(1,3)      --> Rat(3,2)

ans = a ^ 3             --> Rat(1,8)

ans = 2 ^ a             --~ 1.4142

-- comparison
ans = (b == b)          --> true

ans = (a >= b)          --> false

-- greatest common division
ans = Rat.gcd(125,65)   --> 5

-- represent as decimal
ans = a:decimal()       --> 0.5

-- numerator
ans = b:Nu()            --> 2

-- denominator
ans = b:De()            --> 1

-- make copy
ans = a:copy()          --> a

-- show
print(a)
</pre>
<a href="#Top">Top</a>
<a name="Spec"></a>
<h3 align="center"># Spec (special) #</h3>
<p align="center">Специальные математические функции.</p>
<p><b>Dawson(x)</b> - Dawson integral.<br>
<b>Legendre(n,x)</b> - Return list of Legendre polynomial coefficients.<br>
<b>bessi(n,x)</b> - Модифицированная функция Бесселя In(x).<br>
<b>bessj(n,x)</b> - Функция Бесселя первого рода.<br>
<b>bessk(n,x)</b> - Модифицированная функция Бесселя Kn(x).<br>
<b>bessy(n,x)</b> - Функция Бесселя второго рода.<br>
<b>beta(z,w)</b> - Бета-функция.<br>
<b>betainc(x,a,b)</b> - Неполная бета-функция Ix(a,b).<br>
<b>betaln(z,w)</b> - Натуральный логарифм бета-функции.<br>
<b>erf(x)</b> - Функция ошибок.<br>
<b>erfc(x)</b> - Дополнительная функция ошибки.<br>
<b>expint(n,x)</b> - Интегральная экспонента En(x).<br>
<b>gamma(z)</b> - Гамма-функция.<br>
<b>gammainc(x,a,type)</b> - Неполная гамма-функция, P (type='lower') или Q (type='upper').<br>
<b>gammaln(z)</b> - Натуральный логарифм гамма-функции.<br>
<b>gammp(a,x)</b> - Неполная гамма-функция P(a,x).<br>
<b>gammq(a,x)</b> - Неполная гамма-функция Q(a,x) = 1-P(a,x).<br></p>
<pre style="background-color: silver; width: 700px;">
Spec = require 'liblc.special'

-- beta functions
ans = Spec.beta(3,4)               --~ 1.667E-2

ans = Spec.betaln(10,20)           --~ -19.115

ans = Spec.betainc(0.5, 2, 3.3)    --~ 0.7309

-- error functions
ans = Spec.erf(1)                  --~ 0.8427

ans = Spec.erfc(0.5)               --~ 0.4795

-- Ei(x)
ans = Spec.expint(3.3)             --~ 8.939E-3

-- E3(x)
ans = Spec.expint(2, 5)            --~ 9.965E-4

-- gamma functions
ans = Spec.gamma(-1.5)             --~ 2.3633

ans = Spec.gammaln(100)            --~ 359.1342

ans = Spec.gammp(7.7, 2.3)         --~ 3.85E-3

ans = Spec.gammq(1.5, 4.8)         --~ 2.23E-2

-- another syntax
ans = Spec.gammainc(2.1, 0.3, 'upper') --~ 1.942E-2

-- Bessel functions
ans = Spec.bessj(3, 1.5)           --~ 6.096E-2

ans = Spec.bessy(4, 0.8)           --~ -78.751

ans = Spec.bessi(2, -3.6)          --~ 4.254

ans = Spec.bessk(5, 5)             --~ 3.2706E-2

-- Legendre function
lst = Spec.Legendre(3, 0.5)
ans = lst[1]                       --~ -0.4375

-- Dawson function
ans = Spec.Dawson(3.3)             --~ 0.1598
</pre>
<a href="#Top">Top</a>
<a name="Stat"></a>
<h3 align="center"># Stat (stat) #</h3>
<p align="center">Статистические вычисления. Данные должны быть представлены в виде Lua таблиц.</p>
<p><b>chi2cdf(x,v)</b> - Хи-квадрат распределение.<br>
<b>chi2pdf(x,v)</b> - Плотность хи-квадрат распределения.<br>
<b>cmoment(n,x[,p])</b> - Центральный момент x порядка n, p - список весов.<br>
<b>fcdf(x,v1,v2)</b> - Функция F-распределения.<br>
<b>fpdf(x,v1,v2)</b> - Плотность F-распределения.<br>
<b>freq(t)</b> - Возвращает таблицу с частотами элементов.<br>
<b>geomean(t[,w])</b> - Геометрическое среднее.<br>
<b>harmean(t[,w])</b> - Гармоническое среднее.<br>
<b>hyst(data[,N[,a,b]])</b> - Расчёт гистограммы на интервале [a,b] с N диапазонами. Возвращает шкалу (X) и частоты (Y).<br>
<b>max(t)</b> - Наибольший элемент и его индекс.<br>
<b>mean(t[,w])</b> - Расчёт среднего значения (с учётом весов).<br>
<b>median(t)</b> - Медиана списка.<br>
<b>min(t)</b> - Минимальный элемент и его индекс.<br>
<b>moment(n,x[,p])</b> - Расчёт момента x порядка n, p - список весов.<br>
<b>normcdf(x,mu,sig)</b> - Нормальное распределение.<br>
<b>normpdf(x,nu,sig)</b> - Плотность нормального распределения.<br>
<b>poisscdf(x,lam)</b> - Распределение Пуассона.<br>
<b>poisspdf(x,lam)</b> - Плотность распределения Пуассона.<br>
<b>std(t[,w])</b> - Стандартное отклонение и дисперсия (с учётом весов).<br>
<b>stdcorr(t)</b> - Скорректированные значения стандартного отклонения и дисперсии.<br>
<b>sum(t)</b> - Сумма элементов выборки.<br>
<b>tcdf(x,nu)</b> - Распределение Стьюдента.<br>
<b>tpdf(x,nu)</b> - Плотность распределения Стьюдента.<br></p>
<pre style="background-color: silver; width: 700px;">
Stat = require 'liblc.stat'

-- initial data (tables)
X = {3,2,5,6,3,4,3,1}
w = {1,1,0,1,2,2,1,1}
-- average
ans = Stat.mean(X)                --~ 3.375

-- standard deviation
ans, tmp = Stat.std(X,W)          --~ 1.495

-- variance
ans = tmp                         --~ 2.234

-- maximum element and index
_,ans = Stat.max(X)               --> 4 

-- median
ans = Stat.median(X)              --> 3

-- table of frequencies
tmp = Stat.freq(X)
ans = tmp[3]                      --> 3

-- central moment
ans = Stat.cmoment(2,X)           --~ 2.234

-- non-central moment
ans = Stat.moment(3,X,W)          --~ 61.875

-- summ of elements
ans = Stat.sum(X)                 --> 27

-- corrected standard deviation
ans = Stat.stdcorr(X)             --~ 1.598

-- minimum value
ans = Stat.min(X)                 --> 1

-- geometrical mean
ans = Stat.geomean(X)             --~ 2.995

-- harmonic mean
ans = Stat.harmean(X,W)           --~ 2.567

-- find histogram
h = Stat.hyst(X,4)
ans = h.Y[1]                      --> 2

-- Poisson cdf and pdf
ans = Stat.poisscdf(3, 0.5)       --~ 0.998

ans = Stat.poisspdf(5, 1.1)       --~ 4.467E-3

-- Chi2 cdf and pdf
ans = Stat.chi2cdf(0.5, 2)        --~ 0.2212

ans = Stat.chi2pdf(1.2, 2.1)      --~ 0.2748

-- Student cdf and pdf
ans = Stat.tcdf(4, 2.5)           --~ 0.9805

ans = Stat.tpdf(2, 3.3)           --~ 0.0672

-- F cdf and pdf
ans = Stat.fcdf(0.8, 1.1, 2.2)    --~ 0.5285

ans = Stat.fpdf(1.3, 2.7, 2.4)    --~ 0.2174

-- Gauss cdf and pdf
ans = Stat.normcdf(1, 1.5, 2.1)   --~ 0.4059

ans = Stat.normpdf(0.7, 0.5, 0.8) --~ 0.4833
</pre>
<a href="#Top">Top</a>
<a name="DS"></a>
<h3 align="center"># DS (struct) #</h3>
<p align="center">Базовые структуры данных.</p>
<p><b>Heap([less])</b> - Создаёт новую кучу. Для сравнения элементов может быть переопределён метод 'less'.<br>
<b>Heap.copy(h)</b> - Make copy of the heap.<br>
<b>Heap.isEmpty(h)</b> - Return true if the heap is empty.<br>
<b>Heap.size(h)</b> - Get number of elements in the heap.<br>
<b>Queue()</b> - Создаёт новую очередь.<br>
<b>Queue.copy(q)</b> - Make copy of the queue.<br>
<b>Queue.isEmpty(q)</b> - Return true if the queue is empty.<br>
<b>Queue.peek(q)</b> - Get next element, don't remove it.<br>
<b>Queue.size(q)</b> - Return number of elements in queue.<br>
<b>Set(t)</b> - Create new set from table of elements.<br>
<b>Set.copy(s)</b> - Get copy of the set.<br>
<b>Set.isEmpty(s)</b> - Return true if the set is empty.<br>
<b>Set.size(s)</b> - Number of elements in the set.<br>
<b>Stack()</b> - Создаёт новый стек.<br>
<b>Stack.copy(s)</b> - Create copy of the stack.<br>
<b>Stack.isEmpty(s)</b> - Return true if the stack is empty.<br>
<b>Stack.size(s)</b> - Return number of elements in stack.<br>
<b>add(val)</b> - Помещает элемент в очередь.<br>
<b>addFirst(val)</b> - Add value to the top of queue.<br>
<b>comparison</b> - a==b, a~=b, a<b, a<=b, a>b, a>=b<br>
<b>insert(set,val)</b> - Insert element into set.<br>
<b>insert(v)</b> - Добавляет элемент в кучу.<br>
<b>map(s,fn)</b> - Apply function fn() to obtain new set.<br>
<b>peek()</b> - Возвращает значение следующего элемента не удаляя его.<br>
<b>pop()</b> - Извлекает значение из стека, либо возвращает nil.<br>
<b>push(val)</b> - Помещает в стек новое значение (кроме nil).<br>
<b>rem()</b> - Извлекает из очереди следующий элемент.<br>
<b>remLast()</b> - Get value from the end of queue, remove it.<br>
<b>remove(set,val)</b> - Remove element from set.<br>
<b>table(set)</b> - Represent set as a table.<br>
<b>top()</b> - Return top element. For the default less() function top is maximum.<br>
<b>union, intersection, difference</b> - a+b, a*b, a/b<br></p>
<pre style="background-color: silver; width: 700px;">
DS = require 'liblc.struct'

-- create stack
a = DS.Stack()
-- add values
a:push(1)
a:push(2)
-- stack size
ans = #a                        --> 2

-- top value
ans = a:peek()                  --> 2

-- make copy
aa = a:copy()

-- get value
a:pop()
ans = a:pop()                   --> 1

-- check capacity
ans = a:isEmpty()               --> true

-- create queue
b = DS.Queue()
-- add elements to the tale
b:add(1)
b:add(2)
-- get from the head
ans = b:rem()                   --> 1

-- add to the head
b:addFirst(4)
-- remove from the tale
ans = b:remLast()               --> 2

-- check queue size
ans = #b                        --> 1

-- top value
ans = b:peek()                  --> 4

-- check capacity
ans = b:isEmpty()               --> false

-- make copy
bb = b:copy()

-- create heap
c = DS.Heap()
c:insert(1)
c:insert(3)
c:insert(2)
ans = c:top()                --> 3

-- check capacity
ans = c:isEmpty()               --> false

-- new heap
-- with user comparison function
-- (return minimum element)
d = DS.Heap(function (a,b) return a > b end)
d:insert(1)
d:insert(3)
d:insert(2)
ans = d:top()                --> 1

-- make copy
dd = d:copy()

-- heap size
ans = #dd                       --> 2

-- define elements of the set
a = DS.Set {1,2,3,4,1}           
b = DS.Set {3,4,5}               
ans = a                        --> DS.Set {1,2,3,4}

-- check if 6 in set b
ans = b[6]                     --> nil

-- add value
b:insert(6)
ans = b[6]  
-- remove value             
b:remove(6)                    --> true

-- union
ans = a + b                    --> DS.Set {1,2,3,4,5}

-- intersection
ans = a * b                    --> DS.Set {3,4}

-- difference
ans = a / b                    --> DS.Set {1,2}

-- comparison
ans = (a == b)                 --> false

ans = (a < b)                  --> false

-- represent as list
t = a:table()
ans = a[ t[1] ]                --> true

-- size of the set
ans = #a                       --> 4

-- make copy
d = a:copy()
ans = (d == a)                 --> true

-- generate new set from given
-- use function
e = a:map(function (x) return x^2 end)
ans = e[16]                    --> true

-- show
print(a)
</pre>
<a href="#Top">Top</a>
<a name="Unit"></a>
<h3 align="center"># Unit (units) #</h3>
<p align="center">Операции и преобразования с учётом единиц измерения.</p>
<p><b>Unit(v[,u])</b> - Создание новой величины с заданными единицами измерения.<br>
<b>add(unit,rule)</b> - Добавление правила для преобразования заданных величин.<br>
<b>convert(v, units)</b> - Преобразование единиц измерения, возвращает новый объект или nil.<br>
<b>copy(u)</b> - Копия элемента.<br>
<b>prefix</b> - Таблица возможных префиксов для единиц измерений.<br>
<b>serialize(obj)</b> - Строковое представление объекта с единицами измерения.<br></p>
<pre style="background-color: silver; width: 700px;">
Unit = require 'liblc.units'

-- add some rules
Unit.add('h', Unit(60,'min'))
Unit.add('min', Unit(60,'s'))

-- define variable
a = Unit(1,'m/s')
-- convert to km/h, get only value
ans = a['km/h']                    --> 3.6

-- get numerical value
ans = #a                           --> 1

-- make copy
cp = a:copy() 
ans = cp                           --> Unit(1,'m/s')

-- get converted variable
b = a:convert('km/h')
ans = b                            --> Unit(3.6, 'km/h')

-- arithmetic
b = 3 * b
ans = a + b                        --> Unit(4, 'm/s')

ans = b - a                        --> Unit(2, 'm/s')

ans = a * b                        --> Unit(3, 'm^2/s^2')

ans = b / a                        --> Unit(3)

ans = (a < b)                      --> true

ans = b ^ 3                        --> Unit(27, 'm^3/s^3')

-- new rule
Unit.add('snake', Unit(48, 'parrot'))
-- define variable
c = Unit(2,'snake')
-- convert
ans = c['parrot']                  --> 96

-- convert using prefix
ans = c['ksnake']                  --> 0.002

-- complex rule
d = Unit(1,'W')
-- define function for conversation, apply it
e = d:convert(function (x) return Unit(10*math.log((x/Unit(1,'mW')):simp(),10), 'dBm') end)
ans = #e                           --> 30

-- another definition syntax
ans = 2 * Unit('N')                --> Unit(2,'N')

-- show result
print(a)
</pre>
<a href="#Top">Top</a>
<p align="center"><i>2017-2018, Stanislav Mikhel</i></p>
</body></html>