<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Sonata LC Help</title>
</head><body>
<style type="text/css">
H3 {text-align:center;}
P {line-height:1.3;}
UL {column-count: 4; border: 2px solid blue; border-radius: 5px; padding: 5px 5px 5px 30px;}
DIV {margin-left: 10px;}
.EXAMPLE {border: 2px solid blue; border-radius: 5px; background: lightgrey; padding: 15px; margin: 10px 0px; color:navy; }
.DESCRIPT {text-align:center; font-style:italic; }
</style>
<a name="Top"></a>
<div><h1 align="center">Sonata Lua Calculus</h1>
<ul>
<li><a href="#Arr">array</a></li>
<li><a href="#Big">bigint</a></li>
<li><a href="#Comp">complex</a></li>
<li><a href="#_C">const</a></li>
<li><a href="#File">files</a></li>
<li><a href="#Gnu">gnuplot</a></li>
<li><a href="#Graph">graph</a></li>
<li><a href="#Mat">matrix</a></li>
<li><a href="#Num">numeric</a></li>
<li><a href="#Poly">polynom</a></li>
<li><a href="#Rat">rational</a></li>
<li><a href="#Spec">special</a></li>
<li><a href="#Stat">stat</a></li>
<li><a href="#DS">struct</a></li>
<li><a href="#Unit">units</a></li>
</ul></div>
<div><h3># About #</h3>
<p><br>
'Sonata LC' is a Lua based program for mathematical calculations.<br>
<br>
<b>USAGE</b>:<br>
	lua -i sonata.lua [flag [arg1 arg2 ...]]<br>
(option '-i' could be omitted when the program is in non-interactive mode)<br>
<br>
<b>FLAGS</b>:<br>
	-t, --test - Apply unit tests to desired module, or all modules if the name is not defined.<br>
	-h, --help - Get this help message.<br>
	-n, --new - Generate template for a new module.<br>
	-l, --lng - Create/update file for localization.<br>
	-e, --eval - Read text file and evaluate expressions in ##..##.<br>
	-d, --doc - Create/update documentation file.<br>
<br>
<b>VERSION</b>: 0.9.6<br>
<br>
<b>MODULES</b>: polynom, stat, gnuplot, bigint, complex, units, array, numeric, special, files, graph, struct, rational, const, matrix.<br>
<br>
<b>BUGS</b>: mail to 'sonatalc@yandex.ru'<br>
</p>
<p><a href="https://github.com/mikhel1984/lc/wiki">WIKI</a></p></div>
<div><a name="Main"></a>
<h3># Main (main) #</h3>
<p class="descript">Lua based calculator.</p>
<p><b>_e</b> - Euler number<br>
<b>_pi</b> - Number pi<br>
<b>abs(x)</b> - Absolute value.<br>
<b>acos(x)</b> - Inverse cosine x.<br>
<b>acosh(x)</b> - Hyperbolic arc cosine.<br>
<b>asin(x)</b> - Inverse sine x.<br>
<b>asinh(x)</b> - Hyperbolic inverse sine.<br>
<b>atan(x)</b> - Inverse tangent x.<br>
<b>atan2(y,x)</b> - Inverse tangent of y/x, use signs.<br>
<b>atanh(x)</b> - Hyperbolic inverse tangent.<br>
<b>ceil(x)</b> - Return smallest integer more or equal to x.<br>
<b>cos(x)</b> - Cosine x.<br>
<b>cosh(x)</b> - Hyperbolic cosine.<br>
<b>deg2rad(x)</b> - Convert degrees to radians.<br>
<b>exp(x)</b> - Exponent.<br>
<b>factorial(n)</b> - Evaluate factorial.<br>
<b>floor(x)</b> - Return largest integer less or equal to x.<br>
<b>import</b> - <br>
<b>lc.append(tbl,val)</b> - Append value or table to the given table.<br>
<b>lc.flip(t[,N])</b> - Print Lua table in user-friendly form. Ask about continuation after each N elements (default is 10).<br>
<b>lc.pause([str])</b> - Wait for button press, print text if need.<br>
<b>lc.range([from,]to[,step])</b> - Generate table with sequence of numbers.<br>
<b>lc.sci(x)</b> - 'Scientific' representation of the number.<br>
<b>lc.type(t)</b> - Show type of the object.<br>
<b>log(x)</b> - Natural logarithm.<br>
<b>log10(x)</b> - Decimal logarithm.<br>
<b>max(...)</b> - Maximum number.<br>
<b>min(...)</b> - Minimum number.<br>
<b>rad2deg(x)</b> - Convert radians to degrees.<br>
<b>rand()</b> - Random number between 0 and 1.<br>
<b>randi(N)</b> - Random integer in range from 1 to N.<br>
<b>round(x[,n])</b> - Round value, define number of decimal digits.<br>
<b>sin(x)</b> - Sinus x.<br>
<b>sinh(x)</b> - Hyperbolic sinus.<br>
<b>sqrt(a)</b> - Square root.<br>
<b>tan(x)</b> - Tangent x.<br>
<b>tanh(x)</b> - Hyperbolic tangent.<br></p>
<pre class="example">
lc = require 'liblc.main'

-- constants starts from _
ans = _pi                        --> math.pi

-- round number
ans = round(0.9)                 --> 1.0

-- save 2 digits
ans = round(math.pi, 2)          --> 3.14

-- 'small' factorial - int
ans = factorial(12)              --> 479001600

-- 'big' factorial - float
ans = factorial(50)              --~ 3.0414E+64

-- get object type
ans = lc.type(25)                --> 'integer'

-- show table components
a = {a=1,b=2;3,4,5}
lc.flip(a)

-- generate 'vector'
b = lc.range(3)
ans = b[3]                      --> 3

-- full form
b = lc.range(2,10,2)
ans = b[2]                      --> 4

-- append a to b
lc.append(b,a)
ans = b.b                       --> 2
</pre>
<a href="#Top">Top</a></div>
<div><a name="Arr"></a>
<h3># Arr (array) #</h3>
<p class="descript">Manipulations with arrays of elements.</p>
<p><b>#array</b> - Return maximum number of elements.<br>
<b>Arr(tSize)</b> - Create empty array with given size, represented as a table.<br>
<b>apply(A1,A2,func)</b> - Apply function of 2 arguments. Return new array.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, -a, a^b<br>
<b>comparison</b> - a == b, a ~= b<br>
<b>concat(A1,A2,nAxis)</b> - Array concatenation along the given axis.<br>
<b>copy(A)</b> - Get copy of the array.<br>
<b>dim(A)</b> - Return size of array.<br>
<b>fullString(A,nRow,nCol)</b> - Represent array as sequence of matrices, where r and c are numbers of axes.<br>
<b>get(A,tInd)</b> - Get array element. Index is a table.<br>
<b>isEqual(A1,A2)</b> - Check size equality.<br>
<b>map(A,func)</b> - Apply function of 1 argument. Return new array.<br>
<b>next(A)</b> - Return iterator along all indexes.<br>
<b>rand(tSize)</b> - Return array with random numbers between 0 and 1.<br>
<b>set(A,tInd,val)</b> - Set value to the array. Index is a table.<br>
<b>sub(A,tInd1,tInd2)</b> - Return sub array restricted by 2 indexes.<br></p>
<pre class="example">
-- import 'array'
Arr = require 'liblc.array'

-- empty array
a = Arr {2,3,4}                       
ans = a:get{1,2,1}                     --> nil

-- set values
a:set({1,2,1},4)
ans = a:get{1,2,1}                     --> 4

-- random array
b = Arr.rand {5,2,1}
-- number of elements
ans = #b                               --> 10

ans = b:copy()                         --> b

-- compare sizes
ans = b:isEqual(Arr.rand{5,2,1})       --> true

-- arithmetical operations
c = b + b
ans = c:get{1,1,1}                     --> 2*b:get{1,1,1}

-- get sub array
g = a:sub({1,1,1},{-1,-1,2})         
ans = g:isEqual(Arr{2,3,2})            --> true

-- concatenate along the 3-rd axes
d = Arr.concat(b,b,3)
ans = d:dim()[3]                       --> 2

-- apply functions of 2 arguments
-- to get new array
e = Arr.apply(b,b, function (x,y) return x*y end)
ans = e:get{1,1,1}                     --> (b:get{1,1,1})^2

-- apply function of 1 argument
-- to get new array
f = b:map(function (x) return 10*x end)
ans = f:get{1,1,1}                     --> b:get{1,1,1}*10

-- simple print
print(a)

-- print slices for axis 2 and 3
print(d:fullString(2,3))
</pre>
<a href="#Top">Top</a></div>
<div><a name="Big"></a>
<h3># Big (bigint) #</h3>
<p class="descript">Operations with arbitrary long integers.</p>
<p><b>BASE</b> - The radix of big integer representation.<br>
<b>Big(v)</b> - Create big number from integer or string.<br>
<b>abs(v)</b> - Return module of arbitrary long number.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a%b, a^b, -a, #a<br>
<b>comparison</b> - a<b, a<=b, a>b, a>=b, a==b, a~=b<br>
<b>copy(v)</b> - Return copy of given number.<br>
<b>digits(B)</b> - Number of digits, the same as #B.<br>
<b>eq(a,b)</b> - Check equality of two values.<br>
<b>fact(B)</b> - Return factorial of non-negative integer n.<br>
<b>str(B[,n])</b> - More readable string representation of the number. Optional argument defines number of digits in a group.<br>
<b>tonumber(N)</b> - Represent current big integer as number if it possible.<br></p>
<pre class="example">
-- import 'bigint'
Big = require 'liblc.bigint'

-- from integer
a = Big(123)         
ans = a:tonumber()           --> 123

-- from string
b = Big('456')        
ans = b:tonumber()           --> 456

-- arithmetical operations
ans = Big.tonumber(a+b)      --> 579

ans = Big.tonumber(a-b)      --> -333

ans = Big.tonumber(a*Big(2)) --> 246

ans = Big.tonumber(b/2)      --> 228

ans = Big.tonumber(b%a)      --> 87

ans = Big.tonumber(a^3)      --> 1860867

-- absolute value
ans = Big.tonumber(Big.abs('-25')) --> 25

-- factorial
c = Big(10):fact()
ans = Big.tonumber(c)  --> 3628800

-- make copy, comparison
d = a:copy()
ans = (a == d)               --> true

ans = (a > b)                --> false

ans = (a == b)               --> false

-- compare with number
ans = a:eq(123)              --> true

-- number of digits
-- in Lua5.1 use 'digits' method
ans = #a                     --> 3

-- simple print
print(a)

-- more friendly representation
print(c:str())
print(c:str(6))
</pre>
<a href="#Top">Top</a></div>
<div><a name="Comp"></a>
<h3># Comp (complex) #</h3>
<p class="descript">Manipulations with complex numbers.</p>
<p><b>Comp(a[,b])</b> - Create new complex number.<br>
<b>Im(Z)</b> - Return the imaginary part.<br>
<b>Re(Z)</b> - Return the real part.<br>
<b>_i</b> - Complex unit.<br>
<b>abs(Z)</b> - Return module of complex number.<br>
<b>arg(Z)</b> - Return argument of complex number.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^b, -a<br>
<b>comparison</b> - a==b, a~=b<br>
<b>conj(Z)</b> - Return the complex conjugate.<br>
<b>copy(Z)</b> - Create copy of the complex number.<br>
<b>cos(Z)</b> - Return cosine of a complex number.<br>
<b>cosh(Z)</b> - Return hyperbolic cosine of a real or complex number.<br>
<b>exp(Z)</b> - Return exponent in for complex argument.<br>
<b>log(Z)</b> - Complex logarithm.<br>
<b>sin(Z)</b> - Return sinus of a complex number.<br>
<b>sinh(Z)</b> - Return hyperbolic sinus of a complex number.<br>
<b>sqrt(Z)</b> - Return square root. Result can be real of complex.<br>
<b>tan(Z)</b> - Return tangent of a complex number.<br>
<b>tanh(Z)</b> - Return hyperbolic tangent of a complex number.<br>
<b>trig(module,angle)</b> - Create complex number using module and angle.<br></p>
<pre class="example">
-- import 'complex'
Comp = require 'liblc.complex'

-- real and imag pars
a = Comp(1,2)
-- or just real                  
b = Comp(3)
ans = b                        --> Comp(3,0)

-- imaginary unit
j = Comp._i
ans = 3+4*j                    --> Comp(3,4)

-- use trigonometrical form
ans = Comp.trig(2,0)           --> Comp(2,0)

-- arithmetic
ans = a + b                    --> Comp(4,2)

ans = Comp(3) - b              --> Comp(0)

ans = a * b                    --> Comp(3,6)

ans = a / Comp._i              --> Comp(2,-1)

-- power could be complex
c = Comp(1,1)^Comp(2,-2)
-- real part
ans = c:Re()                   --~ 6.147

-- imaginary part
ans = c:Im()                   --~ 7.4

-- comparison
ans = (a == b)                 --> false

ans = (a ~= b)                 --> true

-- absolute value
ans = a:abs()                  --~ 2.236

-- argument (angle)
ans = a:arg()                  --~ 1.107

-- conjugated number
ans = a:conj()                 --> Comp(1,-2)

-- complex square root
-- after import becomes default
d = Comp.sqrt(-2)
ans = d:Im()                   --~ 1.414

-- make copy
ans = a:copy()                 --> a

-- show
print(a)
</pre>
<a href="#Top">Top</a></div>
<div><a name="_C"></a>
<h3># _C (const) #</h3>
<p class="descript">Collection of constants.</p>
<p><b>Adams</b> - Answer to the ultimate question of life, the Universe, and Everything.<br>
<b>EuMa</b> - Difference between harmonic series and the natural logarithm.<br>
<b>G</b> - Gravitational constant.<br>
<b>NA</b> - Avogadro's number.<br>
<b>R</b> - Universal gas constant.<br>
<b>Rinf</b> - Rydberg constant<br>
<b>Vm</b> - Volume of one mole of ideal gas.<br>
<b>c</b> - Speed of light.<br>
<b>e</b> - Electron charge.<br>
<b>eps0</b> - Permittivity of free space.<br>
<b>g</b> - Acceleration of free fall.<br>
<b>h</b> - Planck's constant.<br>
<b>k</b> - Boltzmann's constant.<br>
<b>ly</b> - One light year.<br>
<b>mu0</b> - Permeability of free space.<br>
<b>pc</b> - One parsec.<br>
<b>phi</b> - Golden ratio.<br>
<b>sigma</b> - Stefan-Boltzmann constant.<br></p>
<pre class="example">
-- import 'const'
_C = require 'liblc.const'

-- charge of electron
ans = _C.e                  --~ 1.602e-19

-- units has postfix _u
ans = _C.e_u                --> 'C'
</pre>
<a href="#Top">Top</a></div>
<div><a name="File"></a>
<h3># File (files) #</h3>
<p class="descript">Routines for working with data files.</p>
<p><b>dsvRead(fName,del)</b> - Read delimiter separated data as Lua table.<br>
<b>dsvWrite(fname,tbl,delim)</b> - Save Lua table as delimiter separated data into file.<br>
<b>split(str,delim)</b> - Return iterator over substrings separated by the delimiter.<br>
<b>tblExport(fName,tbl)</b> - Save Lua table into file.<br>
<b>tblImport(fName)</b> - Import Lua table, written into file.<br></p>
<pre class="example">
-- import 'files'
File = require 'liblc.files'
-- prepare file name
nm = os.tmpname()

-- save table 
-- separate elements with ';'
t = {{1,2,3},{4,5,6}}
File.dsvWrite(nm, t, ';')

-- read table from file
-- with separator ';'
tt = File.dsvRead(nm, ';')
ans = tt[2][2]                       --> 5

-- get file text as string
s = File.read(nm)
ans = string.sub(s,1,5)              --> '1;2;3'

-- serialize table to file
a = {1, 2.0, a = 'pqr', b = {3,4,c='abc'}}
File.tblExport(nm, a)

-- deserialize table from file
aa = File.tblImport(nm)
ans = aa.b.c                         --> 'abc'

-- string split
str = 'abc//defg//hijkl//mnop'
ans = 0
for s in File.split(str, '//') do ans = ans+1 end  --> 4

</pre>
<a href="#Top">Top</a></div>
<div><a name="Gnu"></a>
<h3># Gnu (gnuplot) #</h3>
<p class="descript">Interface for calling Gnuplot from Lua.</p>
<p><b>Gnu([g])</b> - Transform given table into gnuplot object.<br>
<b>N</b> - If no samples, divide interval into N points.<br>
<b>copy(G)</b> - Get copy of the plot options.<br>
<b>isAvailable(G)</b> - Check if all options in table are predefined in program.<br>
<b>keys</b> -   Options description:<br>
{'sin(x)'}                                   -- print sinus using Gnuplot functions<br>
{math.sin, title='sinus'}                    -- plot using function, define in Lua; add legend<br>
{file='sin.dat', ln=1, lw=2}                 -- plot data from file, use given color and width<br>
{tbl, with='lines'}                          -- plot data from Lua table, use lines<br>
title='Graph name'                           -- set title<br>
xrange={0,10}                                -- range of x from 0 to 10<br>
yrange={-2,2}                                -- range of y<br>
zrange={0,5}                                 -- range of z<br>
trange={1,2}                                 -- range for parametric functions<br>
xtitle='A', ytitle='B'                       -- axes names<br>
terminal='jpeg'                              -- save result as jpeg image<br>
output='my_plot.jpg'                         -- file name<br>
parametric=true                              -- create parametric plot<br>
size='square'                                -- set square size<br>
polar=true                                   -- use polar coordinate system<br>
grid='polar'                                 -- polar grid<br>
legend=false                                 -- don't use legend<br>
surface=true                                 -- plot surface in 3D<br>
samples=200                                  -- define number of points<br>
permanent=true                               -- create in independent window<br>
raw='set pm3d'                               -- set Gnuplot options manually<br>
<br>
<b>plot(g)</b> - Plot data, represented as Lua table.<br></p>
<a href="#Top">Top</a></div>
<div><a name="Graph"></a>
<h3># Graph (graph) #</h3>
<p class="descript">Operations with graphs.</p>
<p><b>BellmanFord(start[,goal]</b> - Shortest path search using Bellman-Ford algorithm.<br>
<b>Dijkstra(g,start[,goal]</b> - Find shortest path using Dijkstra's algorithm. Return table of distances and predecessors. If goal is defined, return path and its length.<br>
<b>Graph(t)</b> - Create new graph.<br>
<b>add(e)</b> - Add new node or edge. Node denoted as a single name, edge is a table of names (and weights if need).<br>
<b>bfs(g,start,goal)</b> - Bredth first search. Return result and found path.<br>
<b>copy()</b> - Get copy of the graph.<br>
<b>dfs(start,goal)</b> - Depth first search. Return result and found path.<br>
<b>edges()</b> - List of graph edges.<br>
<b>isComplete(g)</b> - Check completeness of the graph.<br>
<b>nodes()</b> - List of graph nodes.<br>
<b>remove(e)</b> - Remove node or edge. Node is a single name, edge - talbe of names.<br>
<b>spath(start[,goal])</b> - Find shortest path using algorithm of Dijkstra of Bellman-Ford.<br></p>
<pre class="example">
-- import 'graph'
Graph = require 'liblc.graph'

-- build graph
-- single names - nodes, names in brackets - edges 
-- letter w denotes weight of non directed edge
-- numbers are weigths of directed edges
a = Graph {'a','b',{'a','c'},{'d','e',w=2},{'d','b',4,3}}

-- list of nodes
nd = a:nodes()
ans = #nd                      --> 5

-- list of edges
ed = a:edges()
ans = #ed                      --> 3

-- add node
a:add('h') 
-- add edge
a:add {'a','d'}
-- check size
ans = #a                       --> 6

-- remove edge
a:remove {'a','d'}
-- remove node
a:remove('a')
-- new edge number
ed = a:edges()
ans = #ed                      --> 2

-- make copy
b = a:copy()

-- show
print(b)

</pre>
<a href="#Top">Top</a></div>
<div><a name="Mat"></a>
<h3># Mat (matrix) #</h3>
<p class="descript">Matrix operations. The matrices are spares by default.</p>
<p><b>Cholesky(M)</b> - Cholesky decomposition of positive definite symmetric matrix.<br>
<b>Mat(...)</b> - Create matrix from list of strings (tables).<br>
<b>apply(M1,M2,fn)</b> - Apply fu(v1,v2) to each element of matrices m1 and m2.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^b, -a<br>
<b>comparison</b> - a==b, a~=b<br>
<b>concat(M1,M2,dir)</b> - Concatenate two matrix, dir='h' - in horizontal direction, dir='v' - in vertical<br>
Use M1 .. M2 for horizontal concatenation and M1 // M2 for vertical.<br>
<b>copy(M)</b> - Return copy of matrix.<br>
<b>cross(V1,V2)</b> - Cross product or two 3-element vectors.<br>
<b>det(M)</b> - Calculate determinant.<br>
<b>diag(M[,n])</b> - Get diagonal of the matrix or create new matrix which diagonal elements are given. n is the diagonal index.<br>
<b>dot(V1,V2)</b> - Scalar product of two 3-element vectors<br>
<b>eye(rows[,cols[,init]])</b> - Create identity matrix. Diagonal value (init) can be defined.<br>
<b>fill(rows,cols,fn)</b> - Create matrix, using function fn(r,c).<br>
<b>inv(M)</b> - Return inverse matrix.<br>
<b>lu(M)</b> - LU decomposition for the matrix. Return L,U and P matrices.<br>
<b>map(M,fn)</b> - Apply the given function to all elements, return new matrix.<br>
<b>mapEx(M,fn)</b> - Apply function fn(val,row,col) to all elements, return new matrix.<br>
<b>norm(M)</b> - Euclidean norm.<br>
<b>ones(rows[,cols[,val]])</b> - Create matrix of given numbers (default is 1).<br>
<b>pinv(M)</b> - Pseudo inverse matrix calculation.<br>
<b>rand(rows[,cols])</b> - Create matrix with random numbers from 0 to 1.<br>
<b>rank(M)</b> - Find rank of the matrix.<br>
<b>reduce(M,fn,dir,init)</b> - Evaluate s=fn(s,x) along rows (dir='r') or columns (dir='c'), where s0=init.<br>
<b>rref(A,b)</b> - Perform transformations using Gauss method. Return also determinant.<br>
<b>size(M)</b> - Return number or rows and columns.<br>
<b>sparse(M)</b> - Return sparse matrix.<br>
<b>sqNorm(M,dir)</b> - Calculate square norm along given direction.<br>
<b>sum(M,dir)</b> - Find sum of elements along given direction ('r' or 'c').<br>
<b>table(M)</b> - Convert to simple Lua table.<br>
<b>tr(M)</b> - Get trace of the matrix.<br>
<b>transpose(M)</b> - Return matrix transpose. Shorten form is T().<br>
<b>triang(M)</b> - Matrix triangulation produced by Gaussian elimination.<br>
<b>zeros(rows[,cols])</b> - Create matrix from zeros.<br></p>
<pre class="example">
-- import 'matrix'
Mat = require 'liblc.matrix'

-- define matrix objects
a = Mat {{1,2},{3,4}}             
b = Mat {{5,6},{7,8}}  
-- call in typical way           
ans = a[2][2]                    --> 4 

b[1][1] = 5
-- transpose
c = a:T()
-- use () as alias for get()
ans = c(1,-1)                    --> 3

-- matrix rows and columns
_, ans = a:size()                --> 2

-- arithmetical operations
ans = a + b                      --> Mat {{6,8},{10,12}}

ans = b - a                      --> Mat {{4,4},{4,4}}

ans = a * b                      --> Mat {{19,22},{43,50}}

ans = a / b 
-- determinant
ans = ans:det()                  --~ 1

-- multiply to scalar
ans = 2 * a                      --> Mat {{2,4},{6,8}}

-- add scalar (to all elements)
ans = a - 1                      --> Mat {{0,1},{2,3}}

ans = a ^ 2                      --> Mat {{7,10},{15,22}} 

-- determinant
ans = a:det()                    --> -2

-- inverse matrix
e = a:inv()
ans = e(2,1)                     --> 1.5

-- another call of inversion
e = a^-1
ans = e(2,1)                     --> 1.5

-- object copy
f = a:copy()
ans = (f == a)                   --> true

-- element-wise comparison
ans = (a == b)                   --> false

-- identity matrix
ans = Mat.eye(2)                 --> Mat {{1,0},{0,1}}

-- matrix of zeros
ans = Mat.zeros(2,1)             --> Mat {{0},{0}}

-- matrix of constants = 4
ans = Mat.ones(2,3,4)            --> Mat {{4,4,4},{4,4,4}}

-- matrix of constants = 1
ans = Mat.ones(a,3)              --> Mat {{3,3},{3,3}}

-- horizontal concatenation
ans = a .. b                     --> Mat {{1,2,5,6},{3,4,7,8}}

-- vertical concatenation
ans = a // b                     --> Mat {{1,2},{3,4},{5,6},{7,8}}

-- apply function of 1 argument
ans = a:map(function (x) return x^2 end)          --> Mat {{1,4},{9,16}}

-- apply function which depends on index too
ans = a:mapEx(function (x,r,c) return x-r-c end) --> Mat {{-1,-1},{-0,-0}}

-- use Gauss transform to solve equation
ans = Mat.rref(a, Mat {{5},{11}}) --> Mat {{1,0,1},{0,1,2}}

-- create vector
ans = Mat.V {1,2,3}              --> Mat {{1},{2},{3}}

-- get submatrix
g = Mat {{1,2,3},{4,5,6},{7,8,9}}
ans = g({2,-1},{2,3})           --> Mat {{5,6},{8,9}}

-- random matrix
h = Mat.rand(3,2)
print(h)

-- pseudo inverse matrix
m = Mat {{1,2},{3,4},{5,6}}
n = m:pinv()
ans = n(2,2)                    --~ 0.333

-- get simple copy
k = Mat.eye(3)
k = k:table()
ans = k[2][1]                   --> 0

-- back to matrix
k = Mat(k)
k = k:sparse()
ans = rawget(k[2],1)             --> nil

-- make diagonal matrix
ans = Mat.diag({1,2,3})         --> Mat {{1,0,0},{0,2,0},{0,0,3}}

-- shifted diagonal
ans = g:diag(1)                 --> Mat {{2},{6}}

-- cross-product of 2 vectors
x1 = Mat {{1,2,3}}
x2 = Mat {{4,5,6}}
ans = Mat.cross(x1,x2)          --> Mat {{-3},{6},{-3}}

-- dot product of 2 vectors
ans = Mat.dot(x1,x2)            --> 32

-- LU transform
l,u,p = b:lu()
ans = l[2][1]                   --~ 0.714

-- Cholesky decomposition
m = Mat {{3,1},{1,3}}
m = m:Cholesky()
ans = m[2][2]                   --~ 1.633

-- matrix trace
ans = a:tr()                    --> 5

-- extract first row
m = a({},1)
-- vector doesn't need in 2 indices
ans = m(1)                      --> 1

-- extract last column
-- index can be negative 
m = a(-1,{})
ans = m:get(2)                  --> 4

-- apply summation to each row
ans = a:sum()                   --> Mat {{3},{7}}

-- apply product to each column
-- initial value is 1
ans = a:reduce(function (x,y) return x*y end, 'c', 1) --> Mat {{3,8}}

-- get rank
ans = Mat.ones(2,3):rank()      --> 1
</pre>
<a href="#Top">Top</a></div>
<div><a name="Num"></a>
<h3># Num (numeric) #</h3>
<p class="descript">Group of functions for numerical calculations.</p>
<p><b>Newton(fn,x0)</b> - Find root of equation using Newton's rule, use only one initial condition.<br>
<b>TOL</b> - The solution tolerance (0.001 by default).<br>
<b>diff(fn,x)</b> - Calculate the derivative value for given function.<br>
<b>ode45(fn,tDelta,y0[,param])</b> - Numerical approximation of the ODE solution.<br>
First parameter is differential equation, second - time interval, third - initial function value. List of parameters is optional and can includes time step or exit condition.<br>
Return table of intermediate points and result yn.<br>
<b>solve(fn,a,b)</b> - Find root of equation fn(x)=0 at interval [a,b].<br>
<b>trapez(fn,a,b)</b> - Get integral using trapezoidal rule.<br></p>
<pre class="example">
-- import 'numeric'
Num = require 'liblc.numeric'

-- define tolerance
Num.TOL = 1e-4
-- solve 'sin(x) = 0' for x in (pi/2...3*pi/2)
a = Num.solve(math.sin, math.pi*0.5, math.pi*1.5)
ans = a                                   --~ math.pi

-- Newton method
-- only one initial value
d = Num.Newton(math.sin, math.pi*0.7)
ans = d                                   --~ math.pi

-- numeric derivative
b = Num.diff(math.sin, 0)
ans = b                                   --~ 1

-- numeric integral
c = Num.trapez(math.sin, 0, math.pi)      
ans = c                                   --~ 2

-- solve ODE x*y = x'
-- for x = 0..3, y(0) = 1
-- return table of solutions and y(3)
tbl, yn = Num.ode45(function (x,y) return x*y end, {0,3}, 1)
ans = yn                                  --~ 90.011

-- use matrices for high order equations
Mat = require 'liblc.matrix'

-- y''-2*y'+2*y = 1
-- represent as: x1 = y, x2 = y'
-- so: x1' = x2, x2' = 1+2*x2-2*x1
myfun = function (t,x) return Mat.V {x(2), 1+2*x(2)-2*x(1)} end
_, xn = Num.ode45(myfun, {0,2}, Mat.V{3,2}, {dt=0.2}) 
ans = xn(1)                               --~  -10.54

-- define exit condition
-- from time, current and previous results
cond = function (time,current,previous) return current < 0.1 end
myfun = function (t,x) return -x end
y = Num.ode45(myfun, {0,1E2}, 1, {exit=cond})
ans = y[#y][1]                           --~ 2.56
</pre>
<a href="#Top">Top</a></div>
<div><a name="Poly"></a>
<h3># Poly (polynom) #</h3>
<p class="descript">Operations with polynomials</p>
<p><b>Poly(...)</b> - Create a polynomial.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^n, -a<br>
<b>coef(...)</b> - Return polynomial with given roots.<br>
<b>comparison</b> - a==b, a~=b<br>
<b>copy(P)</b> - Get copy of the polynomial.<br>
<b>der(P)</b> - Calculate derivative of polynomial.<br>
<b>fit(X,Y,ord)</b> - Find polynomial approximation for the line.<br>
<b>int(P[,x0])</b> - Calculate integral, x0 - free coefficient.<br>
<b>real(p)</b> - Find real roots of the polynomial.<br>
<b>val(P,x)</b> - Get value of polynomial P in point x.<br></p>
<pre class="example">
-- import 'polynom'
Poly = require 'liblc.polynom'

-- coefficients in ascendant order
a = Poly {1,2,4,3}           
b = Poly {1,1}   
-- polynomial value for x=0             
ans = a:val(0)                --> 3

-- simplified call
ans = a(0)                    --> 3

-- arithmetic
ans = a + b                   --> Poly {1,2,5,4}

ans = a - b                   --> Poly {1,2,3,2}

ans = b * b                   --> Poly {1,2,1}

ans = a / b                   --> Poly {1,1,3}

ans = a % b                   --> Poly {0}

ans = b ^ 3                   --> Poly {1,3,3,1}

-- integration
-- free coefficient is 0
ans = b:int()                 --> Poly {0.5,1,0}

-- derivative
-- and its value for x=1
ader = a:der()
ans = ader(1)                 --> 11

-- build polynomial using roots
ans = Poly.coef(1,-1)         --> Poly {1,0,-1}

-- make copy and compare
c = a:copy()
ans = (a == c)                --> true

ans = (b == c)                --> false

-- find real roots
e = a:real()
ans = e[1]                    --~ -1.00

-- fit curve with polynomial
-- of 2 order
A={0,1,2,3}
B={-3,2,11,24}
p = Poly.fit(A,B,2)
ans = p(10)                   --~ 227.0

-- simple print
print(a)

-- human-friendly print
-- with variable 's'
d = Poly {2,-2,1}
ans = d:str('s')              --> '2*s^2-2*s+1'
</pre>
<a href="#Top">Top</a></div>
<div><a name="Rat"></a>
<h3># Rat (rational) #</h3>
<p class="descript">Computations with rational numbers.</p>
<p><b>De(v)</b> - Return the denominator of the rational number.<br>
<b>Nu(v)</b> - Return the numerator of rational number.<br>
<b>Rat(m[,n])</b> - Create rational number using num (and denom).<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, -a, a^b} <br>
<b>comparison</b> - a<b, a<=b, a>b, a>=b, a==b, a~=b <br>
<b>copy(R)</b> - Get copy of the rational number.<br>
<b>decimal(v)</b> - Return rational number as decimal.<br>
<b>gcd(a,b)</b> - Calculate the greatest common divisor for two integers.<br>
<b>serialize(obj)</b> - Save internal representation of rational number.<br></p>
<pre class="example">
-- import 'rational'
Rat = require 'liblc.rational'

-- numerator, denominator
a = Rat(1,2)
-- only numerator
b = Rat(2)
ans = b                 --> Rat(2,1)

-- simplification
k = 234781
ans = Rat(2*k,3*k)      --> Rat(2,3)

-- arithmetic
ans = a + b             --> Rat(5,2)

ans = 2 * a             --> Rat(1)

ans = Rat(2,3)*Rat(3,2) --> Rat(1)

ans = a / Rat(1,3)      --> Rat(3,2)

ans = a ^ 3             --> Rat(1,8)

ans = 2 ^ a             --~ 1.4142

-- comparison
ans = (b == b)          --> true

ans = (a >= b)          --> false

-- greatest common division
ans = Rat.gcd(125,65)   --> 5

-- represent as decimal
ans = a:decimal()       --> 0.5

-- numerator
ans = b:Nu()            --> 2

-- denominator
ans = b:De()            --> 1

-- make copy
ans = a:copy()          --> a

-- show
print(a)
</pre>
<a href="#Top">Top</a></div>
<div><a name="Spec"></a>
<h3># Spec (special) #</h3>
<p class="descript">Special mathematical functions.</p>
<p><b>Dawson(x)</b> - Dawson integral.<br>
<b>Legendre(n,x)</b> - Return list of Legendre polynomial coefficients.<br>
<b>bessi(n,x)</b> - Modified Bessel function In(x).<br>
<b>bessj(n,x)</b> - Bessel function of the first kind.<br>
<b>bessk(n,x)</b> - Modified Bessel function Kn(x).<br>
<b>bessy(n,x)</b> - Bessel function of the second kind.<br>
<b>beta(z,w)</b> - Beta function.<br>
<b>betainc(x,a,b)</b> - Incomplete beta function Ix(a,b).<br>
<b>betaln(z,w)</b> - Natural logarithm of beta function.<br>
<b>erf(x)</b> - Error function.<br>
<b>erfc(x)</b> - Complementary error function.<br>
<b>expint(n,x)</b> - Exponential integral En(x).<br>
<b>gamma(z)</b> - Gamma function.<br>
<b>gammainc(x,a,type)</b> - Incomplete gamma function, P (type=lower) or Q (type=upper).<br>
<b>gammaln(z)</b> - Natural logarithm of gamma function.<br>
<b>gammp(a,x)</b> - Incomplete gamma function P(a,x).<br>
<b>gammq(a,x)</b> - Incomplete gamma function Q(a,x) = 1-P(a,x).<br></p>
<pre class="example">
-- import 'special'
Spec = require 'liblc.special'

-- beta functions
ans = Spec.beta(3,4)               --~ 1.667E-2

ans = Spec.betaln(10,20)           --~ -19.115

ans = Spec.betainc(0.5, 2, 3.3)    --~ 0.7309

-- error functions
ans = Spec.erf(1)                  --~ 0.8427

ans = Spec.erfc(0.5)               --~ 0.4795

-- Ei(x)
ans = Spec.expint(3.3)             --~ 8.939E-3

-- E3(x)
ans = Spec.expint(2, 5)            --~ 9.965E-4

-- gamma functions
ans = Spec.gamma(-1.5)             --~ 2.3633

ans = Spec.gammaln(100)            --~ 359.1342

ans = Spec.gammp(7.7, 2.3)         --~ 3.85E-3

ans = Spec.gammq(1.5, 4.8)         --~ 2.23E-2

-- another syntax
ans = Spec.gammainc(2.1, 0.3, 'upper') --~ 1.942E-2

-- Bessel functions
ans = Spec.bessj(3, 1.5)           --~ 6.096E-2

ans = Spec.bessy(4, 0.8)           --~ -78.751

ans = Spec.bessi(2, -3.6)          --~ 4.254

ans = Spec.bessk(5, 5)             --~ 3.2706E-2

-- Legendre function
lst = Spec.Legendre(3, 0.5)
ans = lst[1]                       --~ -0.4375

-- Dawson function
ans = Spec.Dawson(3.3)             --~ 0.1598
</pre>
<a href="#Top">Top</a></div>
<div><a name="Stat"></a>
<h3># Stat (stat) #</h3>
<p class="descript">Statistical calculations. Data set must be a Lua table.</p>
<p><b>chi2cdf(x,v)</b> - Chi-square cumulative distribution.<br>
<b>chi2pdf(x,v)</b> - Chi-square distribution density.<br>
<b>cmoment(n,x[,p])</b> - Central moment of x order n, p is a list of weights.<br>
<b>fcdf(x,v1,v2)</b> - F cumulative distribution.<br>
<b>fpdf(x,v1,v2)</b> - F distribution density.<br>
<b>freq(t)</b> - Return table with frequencies of elements.<br>
<b>geomean(t[,w])</b> - Geometrical mean.<br>
<b>harmean(t[,w])</b> - Harmonic mean.<br>
<b>hyst(data[,N[,a,b]])</b> - Find hystogram for given data on the interval [a,b] with N ranges. Return table with scale (X) and frequencies (Y).<br>
<b>max(t)</b> - Maximal element and its index.<br>
<b>mean(t[,w])</b> - Calculate average value. Weights are can be used.<br>
<b>median(t)</b> - List median.<br>
<b>min(t)</b> - Minimal element and its index.<br>
<b>moment(n,x[,p])</b> - Moment of x order n, p is a list of weights.<br>
<b>normcdf(x,mu,sig)</b> - Normal cumulative distribution.<br>
<b>normpdf(x,nu,sig)</b> - Normal distribution density.<br>
<b>poisscdf(x,lam)</b> - Poisson cumulative distribution.<br>
<b>poisspdf(x,lam)</b> - Poisson distribution density.<br>
<b>std(t[,w])</b> - Standard deviation and variance. Weights are can be used.<br>
<b>stdcorr(t)</b> - Corrected value of standard deviation and variance.<br>
<b>sum(t)</b> - Get sum of all elements.<br>
<b>tcdf(x,nu)</b> - Student's cumulative distribution.<br>
<b>tpdf(x,nu)</b> - Student's distribution density.<br></p>
<pre class="example">
-- import 'stat'
Stat = require 'liblc.stat'

-- initial data (tables)
X = {3,2,5,6,3,4,3,1}
w = {1,1,0,1,2,2,1,1}
-- average
ans = Stat.mean(X)                --~ 3.375

-- standard deviation
ans, tmp = Stat.std(X,W)          --~ 1.495

-- variance
ans = tmp                         --~ 2.234

-- maximum element and index
_,ans = Stat.max(X)               --> 4 

-- median
ans = Stat.median(X)              --> 3

-- table of frequencies
tmp = Stat.freq(X)
ans = tmp[3]                      --> 3

-- central moment
ans = Stat.cmoment(2,X)           --~ 2.234

-- non-central moment
ans = Stat.moment(3,X,W)          --~ 61.875

-- summ of elements
ans = Stat.sum(X)                 --> 27

-- corrected standard deviation
ans = Stat.stdcorr(X)             --~ 1.598

-- minimum value
ans = Stat.min(X)                 --> 1

-- geometrical mean
ans = Stat.geomean(X)             --~ 2.995

-- harmonic mean
ans = Stat.harmean(X,W)           --~ 2.567

-- find histogram
h = Stat.hyst(X,4)
ans = h.Y[1]                      --> 2

-- Poisson cdf and pdf
ans = Stat.poisscdf(3, 0.5)       --~ 0.998

ans = Stat.poisspdf(5, 1.1)       --~ 4.467E-3

-- Chi2 cdf and pdf
ans = Stat.chi2cdf(0.5, 2)        --~ 0.2212

ans = Stat.chi2pdf(1.2, 2.1)      --~ 0.2748

-- Student cdf and pdf
ans = Stat.tcdf(4, 2.5)           --~ 0.9805

ans = Stat.tpdf(2, 3.3)           --~ 0.0672

-- F cdf and pdf
ans = Stat.fcdf(0.8, 1.1, 2.2)    --~ 0.5285

ans = Stat.fpdf(1.3, 2.7, 2.4)    --~ 0.2174

-- Gauss cdf and pdf
ans = Stat.normcdf(1, 1.5, 2.1)   --~ 0.4059

ans = Stat.normpdf(0.7, 0.5, 0.8) --~ 0.4833
</pre>
<a href="#Top">Top</a></div>
<div><a name="DS"></a>
<h3># DS (struct) #</h3>
<p class="descript">Main data structures.</p>
<p><b>Heap([less])</b> - Create new heap object. Comparison method 'less' can be predefined.<br>
<b>Heap.copy(h)</b> - Make copy of the heap.<br>
<b>Heap.insert(v)</b> - Add element to the heap.<br>
<b>Heap.isEmpty(h)</b> - Return true if the heap is empty.<br>
<b>Heap.size(h)</b> - Get number of elements in the heap.<br>
<b>Heap.top()</b> - Return top element. For the default less() function top is maximum.<br>
<b>Queue()</b> - Create new queue.<br>
<b>Queue.add(val)</b> - Add value to the back of queue.<br>
<b>Queue.addFirst(val)</b> - Add value to the top of queue.<br>
<b>Queue.copy(q)</b> - Make copy of the queue.<br>
<b>Queue.isEmpty(q)</b> - Return true if the queue is empty.<br>
<b>Queue.peek(q)</b> - Get next element, don't remove it.<br>
<b>Queue.rem()</b> - Get value from the top of queue, remove it.<br>
<b>Queue.remLast()</b> - Get value from the end of queue, remove it.<br>
<b>Queue.size(q)</b> - Return number of elements in queue.<br>
<b>Set(t)</b> - Create new set from table of elements.<br>
<b>Set.copy(S)</b> - Get copy of the set.<br>
<b>Set.insert(S,val)</b> - Insert element into set.<br>
<b>Set.isEmpty(s)</b> - Return true if the set is empty.<br>
<b>Set.map(s,fn)</b> - Apply function fn() to obtain new set.<br>
<b>Set.remove(S,val)</b> - Remove element from set.<br>
<b>Set.size(s)</b> - Number of elements in the set.<br>
<b>Set.table(S)</b> - Represent set as a table.<br>
<b>Set: comparison</b> - a==b, a~=b, a<b, a<=b, a>b, a>=b<br>
<b>Set: union, intersection, difference</b> - a+b, a*b, a/b<br>
<b>Stack()</b> - Create new stack.<br>
<b>Stack.copy(s)</b> - Create copy of the stack.<br>
<b>Stack.isEmpty(s)</b> - Return true if the stack is empty.<br>
<b>Stack.peek()</b> - Return top value without removing it.<br>
<b>Stack.pop()</b> - Pop value from the stack, return element or nil.<br>
<b>Stack.push(val)</b> - Push value to the stack, except nil.<br>
<b>Stack.size(s)</b> - Return number of elements in stack.<br></p>
<pre class="example">
-- import 'struct'
DS = require 'liblc.struct'

-- create stack
a = DS.Stack()
-- add values
a:push(1)
a:push(2)
-- stack size
ans = #a                        --> 2

-- top value
ans = a:peek()                  --> 2

-- make copy
aa = a:copy()

-- get value
a:pop()
ans = a:pop()                   --> 1

-- check capacity
ans = a:isEmpty()               --> true

-- create queue
b = DS.Queue()
-- add elements to the tale
b:add(1)
b:add(2)
-- get from the head
ans = b:rem()                   --> 1

-- add to the head
b:addFirst(4)
-- remove from the tale
ans = b:remLast()               --> 2

-- check queue size
ans = #b                        --> 1

-- top value
ans = b:peek()                  --> 4

-- check capacity
ans = b:isEmpty()               --> false

-- make copy
bb = b:copy()

-- create heap
c = DS.Heap()
c:insert(1)
c:insert(3)
c:insert(2)
ans = c:top()                --> 3

-- check capacity
ans = c:isEmpty()               --> false

-- new heap
-- with user comparison function
-- (return minimum element)
d = DS.Heap(function (a,b) return a > b end)
d:insert(1)
d:insert(3)
d:insert(2)
ans = d:top()                --> 1

-- make copy
dd = d:copy()

-- heap size
ans = #dd                       --> 2

-- define elements of the set
a = DS.Set {1,2,3,4,1}           
b = DS.Set {3,4,5}               
ans = a                        --> DS.Set {1,2,3,4}

-- check if 6 in set b
ans = b[6]                     --> nil

-- add value
b:insert(6)
ans = b[6]  
-- remove value             
b:remove(6)                    --> true

-- union
ans = a + b                    --> DS.Set {1,2,3,4,5}

-- intersection
ans = a * b                    --> DS.Set {3,4}

-- difference
ans = a / b                    --> DS.Set {1,2}

-- comparison
ans = (a == b)                 --> false

ans = (a < b)                  --> false

-- represent as list
t = a:table()
ans = a[ t[1] ]                --> true

-- size of the set
ans = #a                       --> 4

-- make copy
d = a:copy()
ans = (d == a)                 --> true

-- generate new set from given
-- use function
e = a:map(function (x) return x^2 end)
ans = e[16]                    --> true

-- show
print(a)
</pre>
<a href="#Top">Top</a></div>
<div><a name="Unit"></a>
<h3># Unit (units) #</h3>
<p class="descript">Operations and conversations according the units.</p>
<p><b>Unit(v[,u])</b> - Create new elements with units.<br>
<b>add(unit,rule)</b> - Add new rule for conversation.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^n<br>
<b>comparison</b> - a==b, a~=b, a<b, a<=b, a>b, a>=b<br>
<b>convert(v, units)</b> - Convert one units to another, return new object or nil.<br>
<b>copy(u)</b> - Create copy of the element.<br>
<b>prefix</b> - Table of possible prefixes for units.<br>
<b>serialize(obj)</b> - Save internal representation of units object.<br></p>
<pre class="example">
-- import 'units'
Unit = require 'liblc.units'

-- add some rules
Unit.add('h', Unit(60,'min'))
Unit.add('min', Unit(60,'s'))

-- define variable
a = Unit(1,'m/s')
-- convert to km/h, get only value
ans = a['km/h']                    --> 3.6

-- get numerical value
ans = #a                           --> 1

-- make copy
cp = a:copy() 
ans = cp                           --> Unit(1,'m/s')

-- get converted variable
b = a:convert('km/h')
ans = b                            --> Unit(3.6, 'km/h')

-- arithmetic
b = 3 * b
ans = a + b                        --> Unit(4, 'm/s')

ans = b - a                        --> Unit(2, 'm/s')

ans = a * b                        --> Unit(3, 'm^2/s^2')

ans = b / a                        --> Unit(3)

ans = (a < b)                      --> true

ans = b ^ 3                        --> Unit(27, 'm^3/s^3')

-- new rule
Unit.add('snake', Unit(48, 'parrot'))
-- define variable
c = Unit(2,'snake')
-- convert
ans = c['parrot']                  --> 96

-- convert using prefix
ans = c['ksnake']                  --> 0.002

-- complex rule
d = Unit(1,'W')
-- define function for conversation, apply it
e = d:convert(function (x) return Unit(10*math.log((x/Unit(1,'mW')):simp(),10), 'dBm') end)
ans = #e                           --> 30

-- another definition syntax
ans = 2 * Unit('N')                --> Unit(2,'N')

-- show result
print(a)
</pre>
<a href="#Top">Top</a></div>
<div><p align="center"><i>2017-2018, Stanislav Mikhel</i></p></div>
</body></html>