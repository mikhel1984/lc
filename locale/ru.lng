---------- locale/ru.lng ----------
{
language =	 'Русский',
authors  = [[Станистав Михель]],
---------- dialog ----------
Dialog = {
["intro"]                = [[-------- help([функция]) = справка --------------
--------- import(модуль) = импорт функций -------
--------- run(имя_файла) = выполнить Lua скрипт -
----------------- quit() = выход ----------------
]],
["use_import"]           = [[
Используйте
  import 'module' ['module2' 'module3' ...]
для подключения дополнительных модулей.]],
["done"]                 = [[Выполнено.]],
["alias"]                = [[Используйте имя '%s' для доступа к модулю '%s'.]],
},
---------- main.lua ----------
Main = {
["__module__"]           = [[Программа для математических расчётов на Lua.]],
["_ans"]                 = [[Результат последней операции.]],
["tanh(x)"]              = [[Гиперболический тангенс.]],
["rand()"]               = [[Случайное число от 0 до 1.]],
["acos(x)"]              = [[Арккосинус x.]],
["_pi"]                  = [[Число pi.]],
["lc.range([from,]to[,step])"] = [[Генерация последовательности чисел на указанном интервале (с заданным шагом).]],
["randi(N)"]             = [[Случайное целое число от 1 до N.]],
["sqrt(a)"]              = [[Квадратный корень числа.]],
["lc.evalTF(src[,dst])"] = [[Функция читает текст из файла, вычисляет выражения, заключённые в ##...##, и замещает их. Результат записывается в новый файл, либо выводится на экран.]],
["sin(x)"]               = [[Синус x.]],
["acosh(x)"]             = [[Гиперболический арккосинус.]],
["sinh(x)"]              = [[Гиперболический синус.]],
["atan(x)"]              = [[Арктангенс x.]],
["lc.type(t)"]           = [[Печатает тип объекта, распознаёт типы, заданные в Sonata.]],
["lc.map(fn,tbl)"]       = [[Вычисляет функцию для всех элементов списка (таблицы), возвращает новый список.]],
["asin(x)"]              = [[Арксинус x.]],
["log(x)"]               = [[Натуральный логарифм.]],
["lc.show(t[,N])"]       = [[Печатает объект Lua. В случае таблицы выводит элементы группами, с запросом на продолжение (по умолчанию, через каждые 10 элементов).]],
["lc.round(x[,n])"]      = [[Округляет число до заданного количества знаков.]],
["cosh(x)"]              = [[Гиперболический косинус.]],
["asinh(x)"]             = [[Гиперболический арксинус.]],
["tan(x)"]               = [[Тангенс x.]],
["atan2(y,x)"]           = [[Арктангенс, который учитывает знаки агрументов.]],
["atanh(x)"]             = [[Гиперболический арктангенс.]],
["abs(x)"]               = [[Абсолютное значение (модуль) числа.]],
["cos(x)"]               = [[Косинус x.]],
["lc.sci(x)"]            = [[Запись числа в 'нучном' виде.]],
["_e"]                   = [[Число Эйлера.]],
["exp(x)"]               = [[Экспоненциальная зависимость.]],
},
---------- gnuplot.lua ----------
Gnu = {
--["__module__"]           = [[Interface for calling Gnuplot from Lua.]],
--["copy(G)"]              = [[Get copy of the plot options.]],
--["plot(g)"]              = [[Plot data, represented as Lua table.]],
--["N"]                    = [[If no samples, divide interval into N points.]],
--["Gnu([g])"]             = [[Transform given table into gnuplot object.]],
--[=[["keys"]                 = [[  Options description:
{'sin(x)'}                                   -- print sinus using Gnuplot functions
{math.sin, title='sinus'}                    -- plot using function, define in Lua; add legend
{file='sin.dat', ln=1, lw=2}                 -- plot data from file, use given color and width
{tbl, with='lines'}                          -- plot data from Lua table, use lines
title='Graph name'                           -- set title
xrange={0,10}                                -- range of x from 0 to 10
yrange={-2,2}                                -- range of y
zrange={0,5}                                 -- range of z
trange={1,2}                                 -- range for parametric functions
xtitle='A', ytitle='B'                       -- axes names
terminal='jpeg'                              -- save result as jpeg image
output='my_plot.jpg'                         -- file name
parametric=true                              -- create parametric plot
size='square'                                -- set square size
polar=true                                   -- use polar coordinate system
grid='polar'                                 -- polar grid
legend=false                                 -- don't use legend
surface=true                                 -- plot surface in 3D
samples=200                                  -- define number of points
permanent=true                               -- create in independent window
raw='set pm3d'                               -- set Gnuplot options manually
]],]=]
--["isAvailable(G)"]       = [[Check if all options in table are predefined in program.]],
},
---------- bigint.lua ----------
Big = {
--["__module__"]           = [[Operations with arbitrary long integers.]],
--["arithmetic"]           = [[a+b, a-b, a*b, a/b, a%b, a^b, -a, #a]],
--["fact(B)"]              = [[Return factorial of non-negative integer n.]],
--["abs(v)"]               = [[Return module of arbitrary long number.]],
--["comparison"]           = [[a<b, a<=b, a>b, a>=b, a==b, a~=b]],
--["eq(a,b)"]              = [[Check equality of two values.]],
--["size(B)"]              = [[Number of digits, the same as #B.]],
--["str(B[,n])"]           = [[More readable string representation of the number. Optional argument defines number of digits in a group.]],
--["Big(v)"]               = [[Create big number from integer or string.]],
--["val(N)"]               = [[Represent current big integer as number if it possible.]],
--["copy(v)"]              = [[Return copy of given number.]],
--["BASE"]                 = [[The radix of big integer representation.]],
},
---------- units.lua ----------
Unit = {
--["__module__"]           = [[Operations and conversations according the units.]],
--["arithmetic"]           = [[U1+U2, U1-U2, U1*u2, U1/U2, U1^n]],
--["convert(v, units)"]    = [[Convert one units to another, return new object or nil.]],
--["prefix"]               = [[Table of possible prefixes for units.]],
--["copy(U)"]              = [[Create copy of the element.]],
--["comparison"]           = [[U1==U2, U1~=U2, U1<U2, U1<=U2, U1>U2, U1>=U2]],
--["Unit(v[,u])"]          = [[Create new elements with units.]],
--["add(unit,rule)"]       = [[Add new rule for conversation.]],
},
---------- stat.lua ----------
Stat = {
--["__module__"]           = [[Statistical calculations. Data set must be a Lua table.]],
--["harmmean(t[,w])"]      = [[Harmonic mean.]],
--["std(t[,w])"]           = [[Standard deviation and variance. Weights are can be used.]],
--["poisspdf(x,lam)"]      = [[Poisson distribution density.]],
--["fpdf(x,v1,v2)"]        = [[F distribution density.]],
--["chi2cdf(x,v)"]         = [[Chi-square cumulative distribution.]],
--["tpdf(x,nu)"]           = [[Student's distribution density.]],
--["geomean(t[,w])"]       = [[Geometrical mean.]],
--["min(t)"]               = [[Minimal element and its index.]],
--["poisscdf(x,lam)"]      = [[Poisson cumulative distribution.]],
--["normpdf(x,nu,sig)"]    = [[Normal distribution density.]],
--["freq(t)"]              = [[Return table with frequencies of elements.]],
--["normcdf(x,mu,sig)"]    = [[Normal cumulative distribution.]],
--["tcdf(x,nu)"]           = [[Student's cumulative distribution.]],
--["moment(n,x[,p])"]      = [[Central moment of x order n, p is a list of weights.]],
--["fcdf(x,v1,v2)"]        = [[F cumulative distribution.]],
--["median(t)"]            = [[List median.]],
--["hyst(data[,N[,a,b]])"] = [[Find hystogram for given data on the interval [a,b] with N ranges. Return table with scale (X) and frequencies (Y).]],
--["mean(t[,w])"]          = [[Calculate average value. Weights are can be used.]],
--["max(t)"]               = [[Maximal element and its index.]],
--["chi2pdf(x,v)"]         = [[Chi-square distribution density.]],
--["sum(t)"]               = [[Get sum of all elements.]],
},
---------- array.lua ----------
Arr = {
--["__module__"]           = [[Manipulations with arrays of elements.]],
--["arithmetic"]           = [[a+b, a-b, a*b, a/b, -a, a^b]],
--["rand(tSize)"]          = [[Return array with random numbers between 0 and 1.]],
--["get(A,tInd)"]          = [[Get array element. Index is a table.]],
--["concat(A1,A2,nAxis)"]  = [[Array concatenation along the given axis.]],
--["map(A,func)"]          = [[Apply function of 1 argument. Return new array.]],
--["apply(func, ...)"]     = [[Apply function of several arguments. Return new array.]],
--["next(A)"]              = [[Return iterator along all indexes.]],
--["#array"]               = [[Return maximum number of elements.]],
--["dim(A)"]               = [[Return size of array.]],
--["set(A,tInd,val)"]      = [[Set value to the array. Index is a table.]],
--["Arr(tSize)"]           = [[Create empty array with given size, represented as a table.]],
--["sub(A,tInd1,tInd2)"]   = [[Return sub array restricted by 2 indexes.]],
--["isEqual(A1,A2)"]       = [[Check size equality.]],
--["copy(A)"]              = [[Get copy of the array.]],
--["comparison"]           = [[a == b, a ~= b]],
},
---------- struct.lua ----------
DS = {
--["__module__"]           = [[Main data structures.]],
--["Queue.isEmpty(Q)"]     = [[Return true if the queue is empty.]],
--["Heap([less])"]         = [[Create new heap object. Comparison method 'less' can be predefined.]],
--["Queue.front(Q)"]       = [[Get next element, don't remove it.]],
--["Stack.copy(S)"]        = [[Create copy of the stack.]],
--["Queue.pushFront(Q,val)"] = [[Add value to the top of queue.]],
--["Stack()"]              = [[Create new stack.]],
--["Queue.popBack(Q)"]     = [[Get value from the end of queue, remove it.]],
--["Queue()"]              = [[Create new queue.]],
--["Heap.size(H)"]         = [[Get number of elements in the heap.]],
--["Queue.size(q)"]        = [[Return number of elements in queue.]],
--["Stack.push(S,val)"]    = [[Push value to the stack (except nil).]],
--["Queue.push(Q,val)"]    = [[Add value to the back of queue.]],
--["Stack.pop(S)"]         = [[Pop value from the stack, return element or nil.]],
--["Set.list(S)"]          = [[Represent set as a list of elements.]],
--["Set.size(S)"]          = [[Number of elements in the set.]],
--["Stack.top(S)"]         = [[Return top value without removing it.]],
--["Set.remove(S,val)"]    = [[Remove element from set.]],
--["Heap.pop(H)"]          = [[Return top element. For the default less() function top is maximum.]],
--["Queue.copy(Q)"]        = [[Make copy of the queue.]],
--["Set.copy(S)"]          = [[Get copy of the set.]],
--["Stack.isEmpty(S)"]     = [[Return true if the stack is empty.]],
--["Set.map(S,fn)"]        = [[Apply function fn() to obtain new set.]],
--["Set.add(S,val)"]       = [[Insert element into set.]],
--["Set(t)"]               = [[Create new set from table of elements.]],
--["Queue.back(Q)"]        = [[Get next element, don't remove it.]],
--["Set.isEmpty(S)"]       = [[Return true if the set is empty.]],
--["Set: comparison"]      = [[S1==S2, S1~=S2, S1<S2, S1<=S2, S1>S2, S1>=S2]],
--["Heap.top(H)"]          = [[Return value of the top element.]],
--["Heap.push(H,v)"]       = [[Add element to the heap.]],
--["Stack.size(S)"]        = [[Return number of elements in stack.]],
--["Heap.copy(H)"]         = [[Make copy of the heap.]],
--["Heap.isEmpty(H)"]      = [[Return true if the heap is empty.]],
--["Queue.pop(Q)"]         = [[Get value from the top of queue, remove it.]],
--["Set: union, intersection, difference"] = [[S1+S2, S1*S2, S1/S2]],
},
---------- special.lua ----------
Spec = {
--["__module__"]           = [[Special mathematical functions.]],
--["legendre(n,x)"]        = [[Return list of legendre polynomial coefficients.]],
--["besselk(n,x)"]         = [[Modified Bessel function Kn(x).]],
--["besselj(n,x)"]         = [[Bessel function of the first kind.]],
--["beta(z,w)"]            = [[Beta function.]],
--["gammq(a,x)"]           = [[Incomplete gamma function Q(a,x) = 1-P(a,x).]],
--["dawson(x)"]            = [[dawson integral.]],
--["bessely(n,x)"]         = [[Bessel function of the second kind.]],
--["expint(n,x)"]          = [[Exponential integral En(x).]],
--["erf(x)"]               = [[Error function.]],
--["besseli(n,x)"]         = [[Modified Bessel function In(x).]],
--["gammp(a,x)"]           = [[Incomplete gamma function P(a,x).]],
--["gammainc(x,a,type)"]   = [[Incomplete gamma function, P (type=lower) or Q (type=upper).]],
--["erfc(x)"]              = [[Complementary error function.]],
--["gammaln(z)"]           = [[Natural logarithm of gamma function.]],
--["betainc(x,a,b)"]       = [[Incomplete beta function Ix(a,b).]],
--["betaln(z,w)"]          = [[Natural logarithm of beta function.]],
--["gamma(z)"]             = [[Gamma function.]],
},
---------- rational.lua ----------
Rat = {
--["__module__"]           = [[Computations with rational numbers.]],
--["val(R)"]               = [[Return rational number as decimal.]],
--["De(R)"]                = [[Return the denominator of the rational number.]],
--["gcd(a,b)"]             = [[Calculate the greatest common divisor for two integers.]],
--["copy(R)"]              = [[Get copy of the rational number.]],
--["comparison"]           = [[R1<R2, R1<=R2, R1>R2, R1>=R2, R1==R2, R1~=R2]],
--["Nu(R)"]                = [[Return the numerator of rational number.]],
--["Rat(m[,n])"]           = [[Create rational number using num (and denom).]],
--["arithmetic"]           = [[R1+R2, R1-R2, R1*R2, R1/R2, -R, R1^R2} ]],
},
---------- polynom.lua ----------
Poly = {
--["__module__"]           = [[Operations with polynomials]],
--["arithmetic"]           = [[a+b, a-b, a*b, a/b, a^n, -a]],
--["fit(X,Y,ord)"]         = [[Find polynomial approximation for the line.]],
--["build(root1,root2,...)"] = [[Return polynomial with given roots.]],
--["comparison"]           = [[a==b, a~=b]],
--["Poly(...)"]            = [[Create a polynomial.]],
--["val(P,x)"]             = [[Get value of polynomial P in point x.]],
--["real(p)"]              = [[Find real roots of the polynomial.]],
--["der(P)"]               = [[Calculate derivative of polynomial.]],
--["copy(P)"]              = [[Get copy of the polynomial.]],
--["int(P[,x0])"]          = [[Calculate integral, x0 - free coefficient.]],
},
---------- const.lua ----------
_C = {
--["__module__"]           = [[Collection of constants.]],
--["ly"]                   = [[One light year.]],
--["e"]                    = [[Electron charge.]],
--["sigma"]                = [[Stefan-Boltzmann constant.]],
--["NA"]                   = [[Avogadro's number.]],
--["phi"]                  = [[Golden ratio.]],
--["EuMa"]                 = [[Difference between harmonic series and the natural logarithm.]],
--["remove(name)"]         = [[Delete constant.]],
--["c"]                    = [[Speed of light.]],
--["Rinf"]                 = [[Rydberg constant]],
--["Vm"]                   = [[Volume of one mole of ideal gas.]],
--["G"]                    = [[Gravitational constant.]],
--["k"]                    = [[Boltzmann's constant.]],
--["add(name,value)"]      = [[Create new constant.]],
--["h"]                    = [[Planck's constant.]],
--["pc"]                   = [[One parsec.]],
--["g"]                    = [[Acceleration of free fall.]],
--["mu0"]                  = [[Permeability of free space.]],
--["R"]                    = [[Universal gas constant.]],
--["eps0"]                 = [[Permittivity of free space.]],
},
---------- numeric.lua ----------
Num = {
--["__module__"]           = [[Group of functions for numerical calculations.]],
--["der(fn,x)"]            = [[Calculate the derivative value for given function.]],
--["solve(fn,a,b)"]        = [[Find root of equation fn(x)=0 at interval [a,b].]],
--["TOL"]                  = [[The solution tolerance (0.001 by default).]],
--["Newton(fn,x0)"]        = [[Find root of equation using Newton's rule, use only one initial condition.]],
--[=[["ode45(fn,tDelta,y0[,param])"] = [[Numerical approximation of the ODE solution.
First parameter is differential equation, second - time interval, third - initial function value. List of parameters is optional and can includes time step or exit condition.
Return table of intermediate points and result yn.]],]=]
--["trapez(fn,a,b)"]       = [[Get integral using trapezoidal rule.]],
},
---------- complex.lua ----------
Comp = {
--["__module__"]           = [[Manipulations with complex numbers.]],
--["tanh(Z)"]              = [[Return hyperbolic tangent of a complex number.]],
--["sqrt(Z)"]              = [[Return square root. Result can be real of complex.]],
--["comparison"]           = [[a==b, a~=b]],
--["exp(Z)"]               = [[Return exponent in for complex argument.]],
--["cosh(Z)"]              = [[Return hyperbolic cosine of a real or complex number.]],
--["copy(Z)"]              = [[Create copy of the complex number.]],
--["tan(Z)"]               = [[Return tangent of a complex number.]],
--["imag(Z)"]              = [[Return the imaginary part.]],
--["arithmetic"]           = [[a+b, a-b, a*b, a/b, a^b, -a]],
--["trig(module,angle)"]   = [[Create complex number using module and angle.]],
--["Comp([a,]b)"]          = [[Create new complex number.]],
--["cos(Z)"]               = [[Return cosine of a complex number.]],
--["_i"]                   = [[Complex unit.]],
--["sinh(Z)"]              = [[Return hyperbolic sinus of a complex number.]],
--["log(Z)"]               = [[Complex logarithm.]],
--["real(Z)"]              = [[Return the real part.]],
--["angle(Z)"]             = [[Return argument of complex number.]],
--["conj(Z)"]              = [[Return the complex conjugate.]],
--["sin(Z)"]               = [[Return sinus of a complex number.]],
--["abs(Z)"]               = [[Return module of complex number.]],
},
---------- graph.lua ----------
Graph = {
--["__module__"]           = [[Operations with graphs.]],
--["isNegative(G)"]        = [[Check if the graph has negative edges.]],
--["pathD(G,start[,goal])"] = [[Find shortest path using Dijkstra's algorithm. Return table of distances and predecessors. If goal is defined, return path and its length.]],
--["edges(G)"]             = [[List of graph edges.]],
--["nodes(G)"]             = [[List of graph nodes.]],
--["isComplete(G)"]        = [[Check completeness of the graph.]],
--["isDirected(G)"]        = [[Check if the graph has directed edges.]],
--["dfs(G,start,goal)"]    = [[Depth first search. Return result and found path.]],
--["remove(G,e)"]          = [[Remove node or edge from the graph G. Node is a single name, edge - table of names.]],
--["bfs(G,start,goal)"]    = [[Breadth first search. Return result and found path.]],
--["isWeighted(G)"]        = [[Check if the graph has weight different from 1.]],
--["copy(G)"]              = [[Get copy of the graph.]],
--["Graph(t)"]             = [[Create new graph.]],
--["pathBF(G,start[,goal])"] = [[Shortest path search using Bellman-Ford algorithm.]],
--["add(G,e)"]             = [[Add new node or edge to graph G. Node denoted as a single name, edge is a table of names (and weights if need).]],
},
---------- matrix.lua ----------
Mat = {
--["__module__"]           = [[Matrix operations. The matrices are spares by default.]],
--["map(M,fn)"]            = [[Apply the given function to all elements, return new matrix. Function can be in form f(x) or f(x,row,col).]],
--["det(M)"]               = [[Calculate determinant.]],
--["zeros(rows[,cols])"]   = [[Create matrix from zeros.]],
--["pinv(M)"]              = [[Pseudo inverse matrix calculation.]],
--["comparison"]           = [[a==b, a~=b]],
--["Mat(...)"]             = [[Create matrix from list of strings (tables).]],
--["ones(rows[,cols[,val]])"] = [[Create matrix of given numbers (default is 1).]],
--["norm(M)"]              = [[Euclidean norm.]],
--["table(M)"]             = [[Convert to simple Lua table.]],
--["sum(M,dir)"]           = [[Find sum of elements along given direction ('r' or 'c').]],
--["apply(fn,M1,M2,...)"]  = [[Apply function to the given matrices element-wise.]],
--["diag(M[,n])"]          = [[Get diagonal of the matrix or create new matrix which diagonal elements are given. n is the diagonal index.]],
--["rand(rows[,cols])"]    = [[Create matrix with random numbers from 0 to 1.]],
--["tr(M)"]                = [[Get trace of the matrix.]],
--["arithmetic"]           = [[a+b, a-b, a*b, a/b, a^b, -a]],
--["size(M)"]              = [[Return number or rows and columns.]],
--["fill(rows,cols,fn)"]   = [[Create matrix, using function fn(r,c).]],
--["lu(M)"]                = [[LU decomposition for the matrix. Return L,U and P matrices.]],
--["rank(M)"]              = [[Find rank of the matrix.]],
--["eye(rows[,cols[,init]])"] = [[Create identity matrix. Diagonal value (init) can be defined.]],
--["cross(V1,V2)"]         = [[Cross product or two 3-element vectors.]],
--["inv(M)"]               = [[Return inverse matrix.]],
--["chol(M)"]              = [[Cholesky decomposition of positive definite symmetric matrix.]],
--["dot(V1,V2)"]           = [[Scalar product of two 3-element vectors]],
--[=[["concat(M1,M2,dir)"]    = [[Concatenate two matrix, dir='h' - in horizontal direction, dir='v' - in vertical
Use M1 .. M2 for horizontal concatenation and M1 // M2 for vertical.]],]=]
--["rref(M)"]              = [[Perform transformations using Gauss method.]],
--["copy(M)"]              = [[Return copy of matrix.]],
--["reduce(M,fn,dir,init)"] = [[Evaluate s=fn(s,x) along rows (dir='r') or columns (dir='c'), where s0=init.]],
--["transpose(M)"]         = [[Return matrix transpose. Shorten form is T().]],
},
---------- files.lua ----------
File = {
--["__module__"]           = [[Routines for working with files and text.]],
--["dsvWrite(fname,tbl,delim)"] = [[Save Lua table as delimiter separated data into file.]],
--["split(str,delim)"]     = [[Return iterator over substrings separated by the delimiter.]],
--["tblImport(fName)"]     = [[Import Lua table, written into file.]],
--["read(fName)"]          = [[Return file content as a text.]],
--["dsvRead(fName,del)"]   = [[Read delimiter separated data as Lua table.]],
},
}